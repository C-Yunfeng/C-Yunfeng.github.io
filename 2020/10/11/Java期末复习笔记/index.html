

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="杂乱无章 所以记录">
  <meta name="author" content="尘云风">
  <meta name="keywords" content="">
  <title>Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>尘云风</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                Lab
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.chenyunfeng.com/lab/bluerain.html">
                    
                    蓝雨
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="https://www.chenyunfeng.com/lab/yourname.html">
                    
                    你的名字
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://blogjallery.oss-cn-beijing.aliyuncs.com/other/Snipaste_2020-07-21_09-31-03.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-11 17:48" pubdate>
        2020年10月11日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      78
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
            <div class="markdown-body" id="post-body">
              <p>参考资料：</p>
<ul>
<li><p>菜鸟教程</p>
</li>
<li><p>《疯狂Java讲义》——李刚</p>
</li>
</ul>
<h4 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h4><h5 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1.类型转换"></a>1.类型转换</h5><ul>
<li><p>自动类型转换：</p>
<blockquote>
<p>byte——short——int——long——float——double</p>
<p>​                char ——|</p>
<p>1_bit        2_bit       4_bit    8_bit        4_bit       8_bit</p>
</blockquote>
<a id="more"></a>

<p><img src="https://user-images.githubusercontent.com/49241298/72427656-34148100-37c7-11ea-9163-2c610c6d5062.png" srcset="/img/loading.gif"></p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427679-4098d980-37c7-11ea-8509-c49ba6162756.png" srcset="/img/loading.gif"></p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427680-41317000-37c7-11ea-906a-f018dfb6014d.png" srcset="/img/loading.gif"></p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427681-41317000-37c7-11ea-8a29-5e53242e1f83.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<ul>
<li><p>强制类型转换</p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427682-42629d00-37c7-11ea-9a28-ca8b69788426.png" srcset="/img/loading.gif"></p>
</li>
</ul>
<ul>
<li>表达式类型自动提升<ul>
<li>char与其他类型变量运算时，自动转化为int类型再参与运算。</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/49241298/72427683-42fb3380-37c7-11ea-97a9-3417bd8c7fdc.png" srcset="/img/loading.gif"></p>
<ul>
<li><p>总结：</p>
<ul>
<li>低类型可以自动转化为高类型。高类型除了int至char/short/byte，其他的都需要强制类型转换。</li>
</ul>
</li>
</ul>
<h5 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h5><ul>
<li><p>&amp;&amp;与&amp;</p>
<ul>
<li>&amp;&amp;当第一个条件不成立之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止</li>
</ul>
</li>
<li><p>在Java中%是取余运算符，要求两端操作数为整型（×）∵long，int，float，double都可以。</p>
</li>
<li><p>？：：</p>
<pre><code class="hljs java">expression?:s1:s2<span class="hljs-comment">//二者类型相同</span></code></pre>

</li>
</ul>
<h5 id="3-默认初始化"><a href="#3-默认初始化" class="headerlink" title="3.默认初始化"></a>3.默认初始化</h5><ul>
<li>基本数据类型的数组在创建之后，已经赋默认值 0 （或0L、0.0D、0.0F）；引用类型的数组在创建之后，已经赋默认值null(单不能使用)</li>
</ul>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
	<span class="hljs-keyword">static</span> String s;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		String s2;
		<span class="hljs-comment">//System.out.println(s2); //不能用</span>
		System.out.println(s);	<span class="hljs-comment">//类变量，加载时初始化了，null</span>
	&#125;
&#125;

String[] sa=<span class="hljs-keyword">new</span> String [<span class="hljs-number">3</span>];
out.println(sa[<span class="hljs-number">0</span>]);<span class="hljs-comment">//null</span>

<span class="hljs-comment">//String[] sa=new String[] &#123;&#125;;</span>
<span class="hljs-comment">//out.println(sa[0]); //Error</span></code></pre>


<h5 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h5><ul>
<li>switch中只能整型、short、byte、字符型char</li>
</ul>
<h5 id="5-基本类型"><a href="#5-基本类型" class="headerlink" title="5.基本类型"></a>5.基本类型</h5><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>序号</td>
<td>数据类型</td>
<td>字节</td>
<td>封装类</td>
<td>默认值</td>
<td>可表示数据范围</td>
</tr>
<tr>
<td>1</td>
<td>byte(位)</td>
<td>1</td>
<td>Byte</td>
<td>0</td>
<td>-128~127</td>
</tr>
<tr>
<td>2</td>
<td>short(短整数)</td>
<td>2</td>
<td>Short</td>
<td>0</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>3</td>
<td>int(整数)</td>
<td>4</td>
<td>Integer</td>
<td>0</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>4</td>
<td>long(长整数)</td>
<td>8</td>
<td>Long</td>
<td>0</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>5</td>
<td>float(单精度)</td>
<td>4</td>
<td>Float</td>
<td>0.0</td>
<td>1.4E-45~3.4028235E38</td>
</tr>
<tr>
<td>6</td>
<td>double(双精度)</td>
<td>8</td>
<td>Double</td>
<td>0.0</td>
<td>4.9E-324~1.7976931348623157E308</td>
</tr>
<tr>
<td>7</td>
<td>char(字符)</td>
<td>2</td>
<td>Character</td>
<td>空</td>
<td>0~65535</td>
</tr>
<tr>
<td>8</td>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
<td>flase</td>
<td>true或false</td>
</tr>
</tbody></table>
<h4 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h4><h5 id="1-修饰符"><a href="#1-修饰符" class="headerlink" title="1.修饰符"></a>1.修饰符</h5><ol>
<li><p>访问修饰符</p>
<ul>
<li><p>简介：</p>
<blockquote>
<p><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
<p><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p>
<p><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427667-3b3b8f00-37c7-11ea-8ac3-60c57743dba7.png" srcset="/img/loading.gif" alt="7"></p>
</blockquote>
</li>
<li><p>default：</p>
</li>
<li><p>private：</p>
<ul>
<li>被声明为 <strong>private</strong> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明<strong>private</strong></li>
<li>private的方法<strong>不能被子类重写</strong>，因为private修饰的方法对子类是隐藏的，即子类无法访问该方法。</li>
</ul>
</li>
<li><p>protected：</p>
<ul>
<li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
<li>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</li>
<li>接口及接口的成员变量和成员方法不能声明为 protected,如图：<img src="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif" srcset="/img/loading.gif"></li>
</ul>
</li>
<li><p>public：</p>
<ul>
<li>接口里的变量都隐式声明为 <strong>public static final</strong> ,而接口里的方法默认情况下访问权限为 <strong>public</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>非访问修饰符</p>
<ul>
<li><p>简介</p>
<blockquote>
<p>static 修饰符，用来修饰类方法、类变量。</p>
<p>final 修饰符，用来修饰类、方法、变量，<strong>final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</strong></p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
</blockquote>
</li>
<li><p>final</p>
<ul>
<li>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</li>
<li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li>
<li>final方法<strong>可以被继承</strong>，<strong>不能被重写</strong></li>
</ul>
</li>
<li><p>abstract</p>
<ul>
<li><p>抽象类：</p>
<ul>
<li><p><strong>抽象类不能用来实例化对象</strong>，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
</li>
<li><p>一个<strong>类</strong>不能同时被 abstract 和 final 修饰（因为final类不能被继承，就不能在子类中实现，即重写）。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<ul>
<li>抽象类可以包含抽象方法和非抽象方法。</li>
</ul>
<ul>
<li><p>抽象方法：</p>
<ul>
<li><p>抽象方法是一种没有任何实现的方法，该方法的的具体<strong>实现由子类实现（即重写）</strong>。</p>
</li>
<li><p>抽象方法<strong>不能被声明成 final（不能继承所以不能重写） 和 static</strong>。（abstract和static可以同时修饰内部类）</p>
</li>
<li><p>任何继承抽象类的子类必须实现父类的<strong>所有抽象方法</strong>，<strong>除非该子类也是抽象类</strong>。</p>
</li>
<li><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类<strong>可以不包含</strong>抽象方法。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span></span>&#123;
    <span class="hljs-comment">//实现抽象方法</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;
        ......
    &#125;
&#125;</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>synchronized</p>
<blockquote>
<p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDetails</span><span class="hljs-params">()</span></span>&#123;
       
&#125;</code></pre>
</blockquote>
</li>
</ul>
</li>
</ol>
<h5 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h5><ul>
<li><p>简介：</p>
<blockquote>
<p>消除臃肿。子类拥有父类<strong>非 private</strong> 的属性、方法。</p>
</blockquote>
</li>
<li><p>访问控制与继承：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被继承。</li>
</ul>
</li>
<li><p>接口：</p>
<ul>
<li><p>使用 implements 关键字可以变相的使 Java 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;
&#125;
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;
&#125;
 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span> </span>&#123;
&#125;</code></pre>
</li>
<li></li>
</ul>
</li>
<li><p>构造器</p>
<ul>
<li><p>子类是<strong>不继承父类的构造器</strong>（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
</li>
<li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会<strong>自动调用父类的无参构造器</strong>。</p>
</li>
<li><p>类可以只有有参构造器，而没有无参构造器。</p>
</li>
<li><p>父类没有无参构造器，且子类构造器中没有显示调用父类构造器时，报错。</p>
<p>创建子类对象时，先创建父类对象。如果没有super，则调用F()，因为没有，所以报错。</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span></span>&#123;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;
	<span class="hljs-comment">//F()&#123;	&#125;</span>
	F(<span class="hljs-keyword">int</span> i)&#123;
		<span class="hljs-keyword">this</span>.i=i;
	&#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span></span>&#123;
    Test(<span class="hljs-keyword">int</span> i)&#123;	<span class="hljs-comment">//Error，F() not defined  </span>
    	<span class="hljs-comment">//super(i);	//换成super就可以了。</span>
    	<span class="hljs-keyword">this</span>.i=i;
    &#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    	Test t = <span class="hljs-keyword">new</span> Test(<span class="hljs-number">10</span>);
    	System.out.println(t.i);
    &#125;
&#125;</code></pre>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>this与super：</p>
<ul>
<li>构造器不能像其他方法那样直接调用，只能结合new使用。因此<strong>在构造器中</strong>使用this调用构造器时，可以避免创建一个新对象，还可以降低耦合性。</li>
<li>在构造器中，如果使用this/super调用其他的构造器，则该代码应该写在<strong>第一行</strong>。</li>
<li>当子类构造器要给父类中 private 的变量赋值时，就可以<strong>直接使用super</strong>，而非调用赋值函数。</li>
<li></li>
</ul>
</li>
</ul>
<h5 id="3-重写"><a href="#3-重写" class="headerlink" title="3.重写"></a>3.重写</h5><ul>
<li><p>重写方法：</p>
<ul>
<li><strong>方法名</strong>相同、<strong>形参列表</strong>相同、子类中<strong>访问权限</strong>更大。</li>
</ul>
</li>
<li><p>父类的成员方法只能被它的子类重写。</p>
<ul>
<li><strong>返回类型</strong>与被重写方法的返回类型<strong>可以不相同</strong>，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，Java7 及更高版本可以不同）。</li>
<li>如果子类中重写了父类的方法，那子类的对象<strong>无法直接</strong>访问父类被覆盖的方法，而可以在子类的方法中调用该被覆盖的方法。</li>
<li>如果子类中定义了和父类同名的<strong>成员变量</strong>，并不是完全覆盖，只是隐藏，同样可以使用super调用。</li>
<li>如果父类构造器中调用了父类的一个方法，且该方法被子类重写了。当创建子类对象之前创建父类对象时，<strong>调用子类重写之后的方法</strong>。</li>
<li>如果<strong>不能继承</strong>一个方法，<strong>则不能重写</strong>这个方法。因此，private方法不能重写，构造器不能重写。</li>
<li>声明为 <strong>final</strong> 的方法不能被重写。</li>
<li>声明为 <strong>static</strong> 的方法不能被重写，但是能够被再次声明。</li>
</ul>
</li>
</ul>
<h4 id="三、类与对象的应用"><a href="#三、类与对象的应用" class="headerlink" title="三、类与对象的应用"></a>三、类与对象的应用</h4><h5 id="1-对象处理"><a href="#1-对象处理" class="headerlink" title="1.对象处理"></a>1.对象处理</h5><ul>
<li><p>==和equals</p>
<ul>
<li><p>如果两个<strong>基本</strong>的<strong>数值</strong>类型变量，（不论数据类型是否相同），只要值相等，就返回true。</p>
</li>
<li><p>如果两个引用型变量，只有指向同一对象时，==才返回true。</p>
</li>
<li><p>==<strong>不可</strong>用于比较类型上<strong>没有继承关系</strong>的两个对象。</p>
<pre><code class="hljs java">out.println(<span class="hljs-string">&quot;hello&quot;</span>==<span class="hljs-keyword">new</span> Test());<span class="hljs-comment">//因为String和Test没有继承关系，因此报错</span></code></pre>
</li>
<li><p><strong>Object(StringBuffer等许多类)默认提供的equals()只比较对象的地址，因此本质上和==一样。</strong>在实际应用中，常需要重写equals()。</p>
</li>
<li><p>重写equals()的要求：</p>
<ul>
<li>自反性：x.equals(x)为true</li>
<li>对称性：x.equals(y)为true，则y.euqals(x)也应为true</li>
<li>传递性：x.equals(y)为true，y.equals(z)为true，则x.equals(z)也应该为true</li>
<li>一致性：变量不变时，多少次返回结果应一致。</li>
<li>当x不为null时，应使x.equals(null)返回false。</li>
</ul>
</li>
</ul>
</li>
<li><p>常量池：</p>
<ul>
<li><p>常量池保证相同的字符串直接量只有一个，不会产生多个副本。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aaa</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		String s1=<span class="hljs-string">&quot;AstraStar&quot;</span>;
		String s2=<span class="hljs-string">&quot;Astra&quot;</span>;
		String s3=<span class="hljs-string">&quot;Star&quot;</span>;
		
		String s4=<span class="hljs-string">&quot;Astra&quot;</span>+<span class="hljs-string">&quot;Star&quot;</span>;<span class="hljs-comment">//编译时就确定,直接引用常量池中的AstraStar</span>
		String s5=s2+s3; <span class="hljs-comment">//编译时没确定,因此不引用常量池的AstraStar</span>
		String s6=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;AstraStar&quot;</span>);<span class="hljs-comment">//在堆内存，不引用常量池</span>
		
		out.println(
				<span class="hljs-string">&quot;s1:&quot;</span>+System.identityHashCode(s1)+
				<span class="hljs-string">&quot;\ns2:&quot;</span>+System.identityHashCode(s2)+
				<span class="hljs-string">&quot;\ns3:&quot;</span>+System.identityHashCode(s3)+
				<span class="hljs-string">&quot;\ns4:&quot;</span>+System.identityHashCode(s4)+
				<span class="hljs-string">&quot;\ns5:&quot;</span>+System.identityHashCode(s5)+
				<span class="hljs-string">&quot;\ns6:&quot;</span>+System.identityHashCode(s6)
				);
		out.println((s1==s4)+<span class="hljs-string">&quot; &quot;</span>+(s1==s5)+<span class="hljs-string">&quot; &quot;</span>+(s4==s5)+<span class="hljs-string">&quot; &quot;</span>+(s1==s6));
	&#125;
&#125;</code></pre>

<p><img src="https://user-images.githubusercontent.com/49241298/72427669-3c6cbc00-37c7-11ea-9060-d19c3f9b70a5.png" srcset="/img/loading.gif"></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2.final修饰符"></a>2.final修饰符</h5><ul>
<li><p>final成员变量</p>
<ul>
<li>final修饰的成员变量必须<strong>显示地初始化</strong>。</li>
</ul>
</li>
<li><p>final基本类型变量与final引用类型变量</p>
<ul>
<li>对于final修饰的引用类型变量，只能使引用的<strong>地址</strong>不被更改，对象完全可以改变。</li>
</ul>
</li>
<li><p>宏替换</p>
<ul>
<li><p>上文常量池中，我们发现s5=s2+s3不能在编译时确定内容，因此没引用常量池中的s1。而将s2和s3分别用final修饰，则可以使其地址一样：</p>
<pre><code class="hljs java">String str1=<span class="hljs-string">&quot;AB&quot;</span>;
<span class="hljs-keyword">final</span> String str2=<span class="hljs-string">&quot;A&quot;</span>;
<span class="hljs-keyword">final</span> String str3=<span class="hljs-string">&quot;B&quot;</span>;
String str4=str2+str3;
out.println(str1==str4);<span class="hljs-comment">//结果为true</span></code></pre>
</li>
</ul>
</li>
<li><p>final方法</p>
<ul>
<li>可以继承，可以重载，<strong>不可以重写</strong></li>
</ul>
</li>
<li><p>final类</p>
<ul>
<li>不能继承</li>
</ul>
</li>
</ul>
<h5 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h5><ul>
<li><p>抽象方法</p>
<ul>
<li><p>抽象方法与空方法：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;;
<span class="hljs-comment">//抽象方法必须属于抽象类</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;</code></pre>

</li>
</ul>
</li>
</ul>
<h5 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h5><ul>
<li><p><del><strong>接口中全是抽象方法</strong></del>，<em>JDK 1.8 以后，接口里可以有静态方法和方法体了。</em></p>
</li>
<li><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名；接口的字节码文件保存在 .class 结尾的文件中。</p>
</li>
<li><p>接口可以有多个直接父接口，但接口只能继承接口，不能继承类；</p>
</li>
<li><p>接口里定义的是多个类共同的公共行为规范，因此<strong>所有成员都为public访问权限</strong>；</p>
</li>
<li><p>接口中可以包含的成员：</p>
<ul>
<li><p>变量：</p>
<ul>
<li><p>接口中的成员变量<strong>只</strong>能是<strong>静态常量</strong>。在接口里声明的成员变量，会自动加上<strong>public static final</strong>，如下，二行代码结果完全一样：</p>
<pre><code class="hljs java"><span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;
<span class="hljs-comment">//public与final因为共同规范；static因为接口不能实例化，所以static。</span></code></pre>
</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li><p>抽象方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">//public abstract</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;</code></pre>
</li>
<li><p>类方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;		<span class="hljs-comment">//public static。不能加default</span>
    out.println(<span class="hljs-string">&quot; &quot;</span>);
&#125;</code></pre>
</li>
<li><p>默认方法</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-title">l</span><span class="hljs-params">()</span></span>&#123;	<span class="hljs-comment">//default。不能加static，因此只能用接口的实现类的实例调用</span>
    out.println(<span class="hljs-string">&quot; &quot;</span>);
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>内部类：</p>
<ul>
<li>内部接口</li>
<li>枚举</li>
</ul>
</li>
</ul>
</li>
<li><p>一个类实现一个/多个接口之后，必须<strong>重写</strong>这些接口里的<strong>所有抽象</strong>方法。否则该类也必须定义为抽象类。</p>
</li>
<li><p>接口与抽象类：</p>
<ul>
<li>都不可被实例化，都可以包含抽象方法</li>
<li><strong>抽象类可以包含普通方法，而接口不能</strong></li>
<li><strong>抽象类可以定义普通成员变量，而接口不能</strong></li>
<li>接口不包含构造器，而抽象类可以（<strong>不用于创建对象，而是让子类调用，实现抽象类的初始化</strong>）</li>
<li>接口不包含初始化块，而抽象类可以。</li>
<li>一个类只能继承一个类，而一个类可以实现多个接口。</li>
</ul>
</li>
<li><p>接口的使用：</p>
<ul>
<li><p>接口的继承：<del>获得父接口的所有抽象方法、常量</del></p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifA</span></span>&#123;
    <span class="hljs-keyword">int</span> A=<span class="hljs-number">5</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testA</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifB</span></span>&#123;
    <span class="hljs-keyword">int</span> B=<span class="hljs-number">5</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testB</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ifA</span>,<span class="hljs-title">ifB</span></span>&#123;
    <span class="hljs-keyword">int</span> C=<span class="hljs-number">10</span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;
        System.out.println(ifC.C);
    &#125;
&#125;
</code></pre>
</li>
<li><p>类实现</p>
<pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifA</span></span>&#123;
	<span class="hljs-keyword">int</span> a=<span class="hljs-number">10</span>;
	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span></span>;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ifA</span></span>&#123;
	<span class="hljs-comment">//static int geta() &#123; //static method cannot hide geta() from ifA</span>
	<span class="hljs-comment">//int geta() &#123; //cannot reduce the visibility of geta() from ifA</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> ifA.a;
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		Test t=<span class="hljs-keyword">new</span> Test();
		ifA ifa=<span class="hljs-keyword">new</span> Test();
		out.println(t.geta());
		out.println(ifa.geta());
	&#125;
&#125;</code></pre>


</li>
</ul>
</li>
</ul>
<h5 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h5><ul>
<li><p>内部类提供了更好的封装，可以吧内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</p>
</li>
<li><p>内部类和外部类</p>
<ul>
<li>内部类可以多使用三个修饰符：<strong>private、protected、static</strong></li>
<li>非静态内部类不能拥有静态成员，即<strong>静态成员</strong>只能出现在<strong>静态内部类</strong>中。</li>
</ul>
</li>
<li><p>非静态内部类</p>
<ul>
<li><p><strong>非静态内部类里可以直接访问外部类的private的成员，而外部类不能直接访问内部类的变量。</strong></p>
</li>
<li><p>同名变量：</p>
<pre><code class="hljs java">OuterClass.<span class="hljs-keyword">this</span>.str	<span class="hljs-comment">//外部类变量</span>
InnerClass.<span class="hljs-keyword">this</span>.str	<span class="hljs-comment">//内部类变量，或this.str</span></code></pre>
</li>
<li><p>非静态内部类<strong>不</strong>能有<strong>静态成员变量</strong>，<strong>静态方法</strong>，<strong>静态初始化块</strong>。外部类的静态成员不能访问非静态内部类。</p>
</li>
</ul>
</li>
<li><p>静态内部类</p>
<ul>
<li>static的作用是将类的成员变为<strong>类相关</strong>，而非实例相关。因此外部类不能用static修饰，而内部类可以。</li>
</ul>
</li>
<li><p>(非)静态内部类案例：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> w;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i1=<span class="hljs-number">2019</span>;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i2=<span class="hljs-number">2020</span>;
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> w)</span> </span>&#123;	<span class="hljs-comment">//2</span>
		<span class="hljs-keyword">this</span>.w=w;
		&#125;
	<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CowLeg</span></span>&#123;	<span class="hljs-comment">//非静态内部类</span>
		<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> l;
		<span class="hljs-comment">//private static double h;	//非静态内部类不能有静态成员变量</span>
		<span class="hljs-comment">//public static void train() &#123;&#125;	//非静态内部类不能有静态方法</span>
		<span class="hljs-comment">//static &#123;out.print(&quot;a&quot;);&#125;	//非静态内部类不能有静态代码块</span>
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CowLeg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l)</span> </span>&#123;	<span class="hljs-comment">//4</span>
			<span class="hljs-keyword">this</span>.l=l;
		&#125;
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;	<span class="hljs-comment">//5</span>
			out.println(w+<span class="hljs-string">&quot; &quot;</span>+l);	<span class="hljs-comment">//非静态内部类的方法可以直接访问外部类的private成员</span>
			out.println(Cow.<span class="hljs-keyword">this</span>.i1);	<span class="hljs-comment">//如果外内部类有同名变量，可以用Outer.this访问</span>
			out.println(<span class="hljs-keyword">this</span>.l);	<span class="hljs-comment">//等价于out.println(CowLeg.this.l);			</span>
			<span class="hljs-comment">//out.println(Cow.this.i2);	//非静态可以访问静态，但不推荐</span>
		&#125;
	&#125;
	
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticClass</span></span>&#123;	<span class="hljs-comment">//静态内部类</span>
		<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i3=<span class="hljs-number">2021</span>;
		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i4=<span class="hljs-number">2022</span>;
		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info_s</span><span class="hljs-params">()</span> </span>&#123;
			<span class="hljs-comment">//out.pritnln(w);	//静态内部类的方法不能访问外部类的非静态成员</span>
			out.println(i2);	<span class="hljs-comment">//静态内部类的方法可以访问外部类的静态成员</span>
		&#125;
	&#125;
	
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;	<span class="hljs-comment">//3</span>
        out.println(<span class="hljs-keyword">new</span> CowLeg(<span class="hljs-number">1.2</span>).l);	<span class="hljs-comment">//外部类中，可以用new显式创建对象来访问内部类成员</span>
        CowLeg cl=<span class="hljs-keyword">new</span> CowLeg(<span class="hljs-number">1.1</span>);	<span class="hljs-comment">//外部类的非静态方法可以访问非静态内部类</span>
		cl.info();
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_s</span><span class="hljs-params">()</span> </span>&#123;
		out.println(StaticClass.i4);	<span class="hljs-comment">//外部类用静态内部类的类名访问其类成员</span>
		<span class="hljs-comment">//out.println(StaticClass.i3);  //外部类的方法不能用静态内部类的类名访问其非静态成员↓</span>
		out.println(<span class="hljs-keyword">new</span> StaticClass().i3);	<span class="hljs-comment">//但可以用实例来访问</span>
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;	<span class="hljs-comment">//1</span>
		<span class="hljs-comment">//CowLeg cl2=new CowLeg(1.2);	//外部类的静态方法不能访问非静态内部类</span>
		Cow cow=<span class="hljs-keyword">new</span> Cow(<span class="hljs-number">370</span>);
		cow.test();
	&#125;
&#125;</code></pre>

<ul>
<li><p>逻辑图</p>
<p><img src="https://user-images.githubusercontent.com/49241298/72427672-3e367f80-37c7-11ea-996d-91d176b5cbe4.png" srcset="/img/loading.gif"></p>
</li>
</ul>
</li>
<li><p>内部类的应用</p>
<ul>
<li><p>创建静态内部类对象时，不用创建外部类对象。</p>
</li>
<li><p>在外部类以外的地方创建静态内部类对象的语句：</p>
<pre><code class="hljs java">OutClass.InnerClass oi=<span class="hljs-keyword">new</span> OuterClass.InnerClass();</code></pre>
</li>
</ul>
</li>
<li><p>局部内部类？匿名内部类？</p>
</li>
</ul>
<h5 id="6-修饰符总结"><a href="#6-修饰符总结" class="headerlink" title="6.修饰符总结"></a>6.修饰符总结</h5><table>
<thead>
<tr>
<th></th>
<th>外部类/接口</th>
<th>成员变量</th>
<th>方法</th>
<th>构造器</th>
<th>初始化块</th>
<th>内部类</th>
<th>局部成员</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td></td>
<td>√</td>
<td>√</td>
<td><strong>√</strong></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>包访问控制符</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td><strong>√</strong></td>
<td>o</td>
<td>√</td>
<td>o</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>√</td>
<td>√</td>
<td><strong>√</strong></td>
<td></td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>abstract</td>
<td>√</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td><strong>√</strong></td>
<td></td>
</tr>
<tr>
<td>final</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
<td><strong>√</strong></td>
<td>√</td>
</tr>
<tr>
<td>static</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>synchronized</td>
<td></td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td><strong>√</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><img src="https://user-images.githubusercontent.com/49241298/72427674-3ecf1600-37c7-11ea-9150-aedf2ad4d176.png" srcset="/img/loading.gif" alt="11"></li>
<li>synchronized也可以修饰代码块</li>
</ul>
<h4 id="四、Java集合"><a href="#四、Java集合" class="headerlink" title="四、Java集合"></a>四、Java集合</h4><h5 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. Array</h5><ul>
<li><p>一维</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-comment">// 静态初始化：只能指定数组元素的初始值，不能指定长度</span>
    <span class="hljs-keyword">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;
    <span class="hljs-keyword">int</span>[] arr2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;	<span class="hljs-comment">// 简化写法</span>
    <span class="hljs-keyword">int</span>[] arr3 = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;
    <span class="hljs-keyword">int</span>[] arr4 = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;
    <span class="hljs-comment">// Arrays类函数</span>
    out.println(<span class="hljs-string">&quot;arr1.equals(arr2): &quot;</span> + Arrays.equals(arr1, arr2));
    out.println(<span class="hljs-string">&quot;arr1 == arr2: &quot;</span>+(arr1==arr4));
    out.println(<span class="hljs-string">&quot;arr1.equals(arr3): &quot;</span> + Arrays.equals(arr1, arr3));
    out.println(<span class="hljs-string">&quot;arr1 == arr3: &quot;</span>+(arr1==arr3));
    out.println(<span class="hljs-string">&quot;arr3.equals(arr4): &quot;</span> + Arrays.equals(arr3, arr4));
    out.println(<span class="hljs-string">&quot;arr3 == arr4: &quot;</span>+(arr3==arr4));	<span class="hljs-comment">//new省略了，所以实际上创建了另一个对象</span>
    <span class="hljs-comment">//输出数组</span>
    out.println(<span class="hljs-string">&quot;arr1:&quot;</span> + Arrays.toString(arr1)+<span class="hljs-string">&quot;\n&quot;</span>);

    <span class="hljs-comment">// 动态初始化：只能指定长度，系统根据类型不同设置不同的初始值</span>
    <span class="hljs-keyword">int</span>[] a1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// byte、short、int、long初始值为0</span>
    <span class="hljs-keyword">float</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// float、double初始值为0.0</span>
    <span class="hljs-keyword">char</span>[] a3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始值为&#x27;\u0000&#x27;</span>
    <span class="hljs-keyword">boolean</span>[] a4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始值为false</span>
    out.println(<span class="hljs-string">&quot;a1[0]:&quot;</span> + a1[<span class="hljs-number">0</span>]);
    out.println(<span class="hljs-string">&quot;a2[0]:&quot;</span> + a2[<span class="hljs-number">0</span>]);
    out.println(<span class="hljs-string">&quot;a3[0]:&quot;</span> + a3[<span class="hljs-number">0</span>]);	<span class="hljs-comment">//显示为空</span>
    out.println(<span class="hljs-string">&quot;a3[0] == &#x27;\u0000&#x27;:&quot;</span>+(a3[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\u0000&#x27;</span>));
    out.println(<span class="hljs-string">&quot;a4[0]:&quot;</span> + a4[<span class="hljs-number">0</span>]);
&#125;</code></pre>
</li>
<li><p>二维</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
    <span class="hljs-comment">//block1</span>
    <span class="hljs-keyword">int</span> [][]a;
    a=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,len=a.length;i&lt;len;i++) &#123;
        out.println(a[i]);
    &#125;
    a[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];
    a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,len=a[<span class="hljs-number">0</span>].length;i&lt;len;i++) &#123;
        out.println(a[<span class="hljs-number">0</span>][i]);
    &#125;
    Arrays.sort(a[<span class="hljs-number">0</span>]);
    out.println(Arrays.toString(a[<span class="hljs-number">0</span>]));

    <span class="hljs-comment">//block2</span>
    String[][] str1= &#123;
        <span class="hljs-comment">//3, 会报错：cannot convert from int to String[]</span>
        <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>],
        <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;
    &#125;;
    <span class="hljs-keyword">int</span> [][] arr= &#123;
        <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,
        <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]
    &#125;;
&#125;</code></pre>



</li>
</ul>
<h4 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h4><ul>
<li><p>try块与if不同，try后面的{}不能省略，即使只有一行代码。catch也不能省略。</p>
</li>
<li><p>try里声明的变量是代码块内的局部变量，catch不能访问。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myException</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-keyword">try</span> &#123;
			<span class="hljs-keyword">int</span> a=Integer.parseInt(args[<span class="hljs-number">0</span>]);
			<span class="hljs-keyword">int</span> b=Integer.parseInt(args[<span class="hljs-number">1</span>]);
			<span class="hljs-keyword">int</span> c=a/b;
			out.println(<span class="hljs-string">&quot;c:&quot;</span>+c);
			
		&#125;
		<span class="hljs-comment">//catch (RuntimeException re)&#123;&#125; //后面会unreachable，应该先小后大</span>
		<span class="hljs-keyword">catch</span>(IndexOutOfBoundsException ie) &#123;
			out.println(<span class="hljs-string">&quot;数组越界，输入的参数不够&quot;</span>);
		&#125;
		<span class="hljs-comment">//catch(IndexOutOfBoundsException ie) &#123;// already handled by last</span>
		<span class="hljs-comment">//java7之后一个catch可以捕获多种异常</span>
		<span class="hljs-keyword">catch</span> (NumberFormatException|ArithmeticException ne) &#123;
			out.println(<span class="hljs-string">&quot;数字格式异常/算术异常&quot;</span>);
			<span class="hljs-comment">//捕获多异常时，异常变量默认有final修饰，因此下列错误：</span>
			<span class="hljs-comment">//ne =new ArithmeticException(&quot;test&quot;);</span>
		&#125;
		<span class="hljs-keyword">catch</span>(Exception e) &#123;
			out.println(<span class="hljs-string">&quot;未知异常&quot;</span>);
			<span class="hljs-comment">//捕获一种异常时，final修饰</span>
			e=<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;test&quot;</span>);
		&#125;
		<span class="hljs-comment">//不管try是否异常、执行了哪一个catch、甚至try/catch里执行了return，finally总会执行</span>
		<span class="hljs-keyword">finally</span> &#123;
			out.println(<span class="hljs-string">&quot;finally总是被执行&quot;</span>);
			<span class="hljs-comment">//不要在finally里使用return/throw这些强制终止方法的语句;</span>
		&#125;
	&#125;
&#125;</code></pre>
</li>
<li><p>throws</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThrows</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
		test();<span class="hljs-comment">//因为test声明跑出IO异常，因此调用test的方法要么在try-catch中，</span>
				<span class="hljs-comment">//要么在另一个声明throws的方法中</span>
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;
		<span class="hljs-comment">//FIS的构造器声明抛出IO异常，因此调用FIS的代码在try-catch或throws中</span>
		FileInputStream fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>);
	&#125;
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">myThrows</span></span>&#123;
	<span class="hljs-comment">//public void test() throws Exception&#123;&#125;//子类不能声明比父类更大的异常	</span>
&#125;</code></pre>



</li>
</ul>
<ul>
<li><p>throw</p>
</li>
<li><p>catch+throw</p>
</li>
</ul>
<h4 id="六、Swing"><a href="#六、Swing" class="headerlink" title="六、Swing"></a>六、Swing</h4><ul>
<li><p><img src="https://user-images.githubusercontent.com/49241298/72427675-3f67ac80-37c7-11ea-9657-30cb5f39a94c.png" srcset="/img/loading.gif" alt="12"></p>
<pre><code class="hljs java"><span class="hljs-comment">//Component类提供了几个常用方法，见P_383</span>
setLocation(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);
setSize(<span class="hljs-keyword">int</span> width,<span class="hljs-keyword">int</span> height);
setBounds(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w,<span class="hljs-keyword">int</span> h);
setVisvle(Boolean b);
<span class="hljs-function">Component <span class="hljs-title">add</span><span class="hljs-params">(Component comp)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getComponentCount</span><span class="hljs-params">()</span></span>;
Component[] getComponents();</code></pre>



</li>
</ul>
<ul>
<li><p>\1.     Applet是一种特殊的Panel，它是Java Applet程序的最外层容器。</p>
</li>
<li><p>\1.     panel（含applet）的默认布局是流式布局，window（frame和dialog）是边界布局</p>
</li>
<li><p>\1.     java Applet 程序必须在浏览器中执行</p>
</li>
<li></li>
</ul>
<h5 id="1-ActionListener"><a href="#1-ActionListener" class="headerlink" title="1. ActionListener:"></a>1. ActionListener:</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> String COMMAND_OK = <span class="hljs-string">&quot;OK&quot;</span>;
<span class="hljs-keyword">final</span> String COMMAND_CANCEL = <span class="hljs-string">&quot;Cancel&quot;</span>;

JButton okBtn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;OK&quot;</span>);
okBtn.setActionCommand(COMMAND_OK);             <span class="hljs-comment">// 按钮绑定动作命令</span>

JButton cancelBtn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;Cancel&quot;</span>);
cancelBtn.setActionCommand(COMMAND_CANCEL);     <span class="hljs-comment">// 按钮绑定动作命令</span>

<span class="hljs-comment">// 创建一个动作监听器实例</span>
ActionListener listener = <span class="hljs-keyword">new</span> ActionListener() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;
        <span class="hljs-comment">// 获取事件源，即触发事件的组件（按钮）本身</span>
        <span class="hljs-comment">// e.getSource();</span>
    
        <span class="hljs-comment">// 获取动作命令</span>
        String command = e.getActionCommand();
        
        <span class="hljs-comment">// 根据动作命令区分被点击的按钮</span>
        <span class="hljs-keyword">if</span> (COMMAND_OK.equals(command)) &#123;
            System.out.println(<span class="hljs-string">&quot;OK 按钮被点击&quot;</span>);
            
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (COMMAND_CANCEL.equals(command)) &#123;
            System.out.println(<span class="hljs-string">&quot;Cancel 按钮被点击&quot;</span>);
        &#125;
    &#125;
&#125;;

<span class="hljs-comment">// 设置两个按钮的动作监听器（使用同一个监听器实例）</span>
okBtn.addActionListener(listener);
cancelBtn.addActionListener(listener);</code></pre>

<h5 id="2-JButton"><a href="#2-JButton" class="headerlink" title="2. JButton"></a>2. JButton</h5><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.*;
<span class="hljs-keyword">import</span> java.awt.event.ActionEvent;
<span class="hljs-keyword">import</span> java.awt.event.ActionListener;
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        JFrame jf = <span class="hljs-keyword">new</span> JFrame(<span class="hljs-string">&quot;测试窗口&quot;</span>);
        jf.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
        jf.setLocationRelativeTo(<span class="hljs-keyword">null</span>);
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        JPanel panel = <span class="hljs-keyword">new</span> JPanel();
        <span class="hljs-comment">// 创建一个按钮</span>
        <span class="hljs-keyword">final</span> JButton btn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;测试按钮&quot;</span>);
        <span class="hljs-comment">// 添加按钮的点击事件监听器</span>
        btn.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;
                <span class="hljs-comment">// 获取到的事件源就是按钮本身</span>
                <span class="hljs-comment">// JButton btn = (JButton) e.getSource();</span>
                System.out.println(<span class="hljs-string">&quot;按钮被点击&quot;</span>);
            &#125;
        &#125;);
        panel.add(btn);
        jf.setContentPane(panel);
        jf.setVisible(<span class="hljs-keyword">true</span>);
    &#125;
&#125;</code></pre>



<h4 id="七、多线程"><a href="#七、多线程" class="headerlink" title="七、多线程"></a>七、多线程</h4><ul>
<li><p>创建线程类</p>
<ul>
<li><p>继承Thread类：多个线程不能共享线程类的实例变量</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">10</span>;i++) &#123;
			System.out.println(getName()+<span class="hljs-string">&quot; &quot;</span>+i);	
			<span class="hljs-comment">//System.out.println(this.getName()+&quot;&quot;+i);	</span>
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;
			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);
			<span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>) &#123;
				<span class="hljs-keyword">new</span> FirstThread().start();
				<span class="hljs-keyword">new</span> FirstThread().start();
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p><img src="https://user-images.githubusercontent.com/49241298/72427676-4098d980-37c7-11ea-8593-557851f20737.png" srcset="/img/loading.gif" alt="13"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>继承Runnable类</li>
</ul>
<ul>
<li><p>线程的生命周期</p>
<p>新状态：线程已被创建但尚未执行（）。</p>
<p>可执行状态(就绪)：线程可以执行，虽然不一定正在执行。CPU 时间随时可能被分配给该线程，从而使得它执行(调用start方法后)</p>
<p>死亡状态：正常情况下 run() 返回使得线程死亡。调用 stop()或 destroy() 亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。</p>
<p>阻塞状态：线程不会被分配 CPU 时间，无法执行。</p>
<p>运行状态 获得调度，执行线程的run方法</p>
</li>
<li><p>启动线程应该用start，而非run；</p>
</li>
<li><p>线程死亡</p>
<ul>
<li>线程结束后就处于死亡状态，结束方式：<ul>
<li>run()或call()执行完成，线程正常结束</li>
<li>线程抛出未捕获的异常/Error</li>
<li>调用线程的stop()</li>
</ul>
</li>
</ul>
</li>
<li><p>控制线程</p>
<ul>
<li>join</li>
<li>后台</li>
<li>sleep</li>
<li>让步yield</li>
</ul>
</li>
</ul>
<h4 id="八、输入输出"><a href="#八、输入输出" class="headerlink" title="八、输入输出"></a>八、输入输出</h4><h4 id="九、JDBC"><a href="#九、JDBC" class="headerlink" title="九、JDBC"></a>九、JDBC</h4><ul>
<li>JDBC是java 数据库连接API，它能完成3 件事，即与一个数据库建立连接、向数据库发送SQL 语句、处理数据库返回的结果。</li>
</ul>
<h4 id="N-1"><a href="#N-1" class="headerlink" title="N+1"></a>N+1</h4><ul>
<li><p>Java 具有简单、面向对象、稳定、与平台无关、解释型、多线程、动态等特点。</p>
</li>
<li><p>jdb.exe是Java调试器，如果编译器返回程序代码的错误，可以用它对程序进行调试；java.exe运行Java程序；javac.exe编译Java程序</p>
<pre><code class="hljs java">javac Hello.java
java Hello</code></pre>



</li>
</ul>
<ul>
<li><p>序列化</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span>
<span class="hljs-class"></span>&#123;
   <span class="hljs-keyword">public</span> String name;
   <span class="hljs-keyword">public</span> String address;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> SSN;
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> number;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span></span>
<span class="hljs-function">   </span>&#123;
      System.out.println(<span class="hljs-string">&quot;Mailing a check to &quot;</span> + name
                           + <span class="hljs-string">&quot; &quot;</span> + address);
   &#125;
&#125;
<span class="hljs-comment">//请注意，一个类的对象要想序列化成功，必须满足两个条件：</span>
<span class="hljs-comment">//该类必须实现 java.io.Serializable 接口。</span>
<span class="hljs-comment">//该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</span>
</code></pre>

</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/10/11/Linear-Regression/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/11/hexo%E4%B8%BB%E9%A2%98fluid%E7%9A%84%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
