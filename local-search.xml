<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"/>
    <url>/2020/10/11/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="四、一元函数微分学的概念与计算"><a href="#四、一元函数微分学的概念与计算" class="headerlink" title="四、一元函数微分学的概念与计算"></a>四、一元函数微分学的概念与计算</h4><h5 id="1-引例"><a href="#1-引例" class="headerlink" title="1. 引例"></a>1. 引例</h5><h5 id="2-导数的概念"><a href="#2-导数的概念" class="headerlink" title="2. 导数的概念"></a>2. 导数的概念</h5><p>$f’(x)=\lim_{x→x_0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}=lim_{x→x_0}\frac{f(x)-f(x_0)}{x-x_0}$.</p><ul><li><p>可导/导数存在→左导数=右倒数。</p><ul><li><p><font color='red'>一点处导数值与去心邻域内导数（或左右导数）无关</font>。换句话说，$f’(x_0)=f’(x)|_{x=x_0}$与$lim_{x→x_0}f’(x)$无关，即“邻域内导数”是一个极限的过程，与$x_0$点无关。</p><ul><li><p>①点导数存在，去心邻域内不存在</p><p>$f(x)=\begin{cases}\frac{x}{2}+x^2sin(\frac{1}{x}),x\not=0\0,x=0\end{cases}$.易证①连续②在$R$点点可微③$x=0$处导数值$f’(0)=\frac{1}{2}&gt;0$，但在其去心邻域内导数震荡不存在（即在$\stackrel{o}{U}$内不可导）。如图所示，$x→0$时，$f(x)$在$y=\frac{x}{2}$附近振荡，并不单调：</p><p><img src="https://pic1.zhimg.com/80/9d457a7b18ca6490b6ff7923e1a8aeb2_720w.jpg" alt="img"></p></li></ul></li></ul></li></ul><pre><code>- ②点导数不存在，去心邻域内存在  $f(x)=\begin&#123;cases&#125;x,x≤0\\x+2,x&gt;0\end&#123;cases&#125;$.在$x=0$处导数不存在，但在去心邻域内导数都存在，且都为1.- **同理，二阶导在一点处的导数值与去心邻域内的导数无关**。</code></pre><ul><li><p>同理，在无穷区间上二者也无关系</p><ul><li>如$f(x)=sinx$，在$(-\infty,+\infty)$上点点可导，且导函数为$cosx$，但$lim_{x→\infty}cosx$不存在。<font color='deepskyblue'>【660-168，660-47】</font>.</li></ul></li></ul><ul><li>$f’(x)$不存在$\begin{cases}\infty的不存在\不唯一的不存在\end{cases}$.</li></ul><a id="more"></a><h5 id="3-微分的概念"><a href="#3-微分的概念" class="headerlink" title="3. 微分的概念"></a>3. 微分的概念</h5><h5 id="4-四则运算"><a href="#4-四则运算" class="headerlink" title="4. 四则运算"></a>4. 四则运算</h5><h6 id="4-N-复合运算"><a href="#4-N-复合运算" class="headerlink" title="4.N 复合运算"></a>4.N 复合运算</h6><ul><li><p>常见结论</p><ul><li><p>设$f(x)$在$x=a$处可导，判断$|f(x)|$的可导性：</p><p>若$f(a)\not=0$，则$|f(x)|$在$x=a$处可导；</p><p>若$f(a)=0$，$\begin{cases}f’(a)=0，|f(x)|可导\f’(a)\not=0，|f(x)|不可导\end{cases}$.</p></li></ul></li></ul><h5 id="5-分段函数的导数"><a href="#5-分段函数的导数" class="headerlink" title="5. 分段函数的导数"></a>5. 分段函数的导数</h5><ul><li>在分段点，用导数定义</li><li>在非分段点，用导数公式</li></ul><h5 id="6-复合函数的导数与微分形式不变性"><a href="#6-复合函数的导数与微分形式不变性" class="headerlink" title="6. 复合函数的导数与微分形式不变性"></a>6. 复合函数的导数与微分形式不变性</h5><ul><li><h5 id="7-反函数的导数"><a href="#7-反函数的导数" class="headerlink" title="7. 反函数的导数"></a>7. 反函数的导数</h5></li></ul><h5 id="8-参数方程所确定的函数的导数"><a href="#8-参数方程所确定的函数的导数" class="headerlink" title="8. 参数方程所确定的函数的导数"></a>8. 参数方程所确定的函数的导数</h5><h5 id="9-隐函数求导法"><a href="#9-隐函数求导法" class="headerlink" title="9. 隐函数求导法"></a>9. 隐函数求导法</h5><h5 id="10-对数求导法"><a href="#10-对数求导法" class="headerlink" title="10. 对数求导法"></a>10. 对数求导法</h5><h5 id="11-幂指函数求导"><a href="#11-幂指函数求导" class="headerlink" title="11. 幂指函数求导"></a>11. 幂指函数求导</h5><ul><li>导数是研究函数形态的基本工具</li></ul><h4 id="五、应用（一）——几何应用"><a href="#五、应用（一）——几何应用" class="headerlink" title="五、应用（一）——几何应用"></a>五、应用（一）——几何应用</h4><h5 id="1-渐近线"><a href="#1-渐近线" class="headerlink" title="1. 渐近线"></a>1. 渐近线</h5><ul><li><p>铅锤渐近线：$lim_{x→x_0^-}=\infty或lim_{x→x_0^+}=\infty$，则$x=x_0$是一条铅锤渐近线</p><ul><li>【铅锤渐近线的判别只需要一边邻域就可以，因此<strong>铅锤渐近线处的x值不一定是无穷间断点</strong>】</li><li>【$x_0$一般是函数的无定义点】</li></ul></li><li><p>水平渐近线：$lim_{x→+\infty}=C或lim_{x→-\infty}=C$，则$y=C$是一条水平渐近线</p><ul><li></li></ul></li><li><p>斜渐近线：若$lim_{x→\infty}\frac{f(x)}{x}=k,(k\not=0)，且\lim_{x→\infty}(f(x)-kx)=b$，则$y=kx+b$是一条斜渐近线【$\infty$只需要一边就行，为了省空间，定义没写那么严谨】</p><ul><li><p>从上式中可以看出，$f(x)与kx同阶$，因此$f(x)$走的太快的或太慢的有没有斜渐近线，例题：</p></li><li><p>【例】下列有斜渐近线的是：</p><p>A) $y=x+sinx$. B) $y=x+sin\frac{1}{x}$. C) $y=x^2+sinx$</p><p>【解】根据上点描述，排除C，因为A)没有截距b，所以选A</p></li><li><p>可以发现，当$k=0$时变成了水平渐近线，当$k=\infty$时变成了铅锤渐近线</p></li></ul></li><li><p><strong>求渐近线的程序</strong>：</p><p>①先找无定义点$x_0$，求$lim_{x→x_0/x_0^+/x_0^-}是否为\infty$，若是$\infty$，则$x=x_0$是铅锤渐近线</p><p>②求$lim_{x→\infty/+\infty/-\infty}f(x)是否为C$，若为C，则$y=C$是水平渐近线</p><p>③若$lim_{x→\infty/+\infty/-\infty}f(x)=\infty$，则</p><p>​    1° $lim_{x→\infty}\frac{f(x)}{x}$是否为非零常数$k$，<strong>【注意$x&lt;0时，\frac{x}{\sqrt{x+x^2}}=-\frac{1}{\frac{1}{x}+1}$，得到的$k$可能共轭】</strong>.</p><p>​    2° $lim_{x→\infty}(f(x)-kx)$是否为常数$b$，</p><p>​    3° 若1°和2°均存在，则为斜渐近线</p></li><li><p>例题</p><ul><li><p>曲线$y=\frac{1}{x}+ln(1+e^x)$有几条渐近线</p></li><li><p>【例5.16】曲线$y=e^{\frac{1}{x^2}}arctan\frac{x^2+x+1}{(x-1)(x+2)}$的渐近线有几条</p><blockquote><p>2</p></blockquote></li></ul></li></ul><h5 id="2-最值（值域）"><a href="#2-最值（值域）" class="headerlink" title="2. 最值（值域）"></a>2. 最值（值域）</h5><ul><li>区间内部的最值一定是极值点【不是端点】</li><li>极值与最值的判别</li><li>求闭区间$[a,b]$上连续函数$f(x)$的最大值和最小值</li><li>求开区间$(a,b)$上连续函数$f(x)$的最大值与最小值</li></ul><h5 id="3-拐点"><a href="#3-拐点" class="headerlink" title="3. 拐点"></a>3. 拐点</h5><h6 id="3-1-拐点的判别"><a href="#3-1-拐点的判别" class="headerlink" title="3.1 拐点的判别"></a>3.1 拐点的判别</h6><ul><li><p>必要条件</p></li><li><p>充分条件</p><ul><li><p>第一充分条件：</p><p>若函数$f(x)$在点$x_0$处连续，在$\stackrel{o}{U}$内可导，在$x_0$的左右邻域内$f’’(x)$变号，则$x_0$是一个拐点。<font color='red'>【判断拐点，只需要看①$f’’(x)=0$和$f’’(x)$不存在的点】</font>.</p><blockquote><p>①仅需要在$x_0$这一点处连续即可</p><p>②在邻域$\stackrel{o}{U}$内可导，即左邻域内可导+右邻域内可导。与$x_0$点处是否可导无关。</p><p>③在$\stackrel{o}{U}$内$f’’(x)$变号即可，与$x_0$处的$f’’(x_0)$无关。 </p><p><font color='deepskyblue'>【660-160,660-161】</font>.</p></blockquote><blockquote><p>关于去心邻域内$f’’(x)$变号的问题：</p><p>①只能变一次号</p><p>②对于无穷间断点，如果两侧无穷大变号，也可以。如$lim_{x→x_0^-}f’’(x)=+\infty,lim_{x→x_0^+}f’’(x)=-\infty$，其他条件满足的情况下，也是拐点。<font color='deepskyblue'>【660-169,660-170】</font>.</p><p>③相对于②，震荡间断点就不行，因为$f’’(x)$反复变号。</p></blockquote></li><li><p>第二充分条件</p></li><li><p>第三充分条件</p></li></ul></li></ul><h4 id="六、应用（二）——中值定理、微分等式、微分不等式"><a href="#六、应用（二）——中值定理、微分等式、微分不等式" class="headerlink" title="六、应用（二）——中值定理、微分等式、微分不等式"></a>六、应用（二）——中值定理、微分等式、微分不等式</h4><p><font color='red'><strong>设$f(x)$在$[a,b]$上连续：</strong></font></p><h5 id="1-f-x-相关"><a href="#1-f-x-相关" class="headerlink" title="1. $f(x)$相关"></a>1. $f(x)$相关</h5><h6 id="第一个：有界与最值定理"><a href="#第一个：有界与最值定理" class="headerlink" title="第一个：有界与最值定理"></a>第一个：有界与最值定理</h6><ul><li>若$m≤f(x)≤M$，则在区间$[a,b]$内，函数$f(x)$一定有最大值和最小值.<ul><li><strong>闭区间有界函数必有最值</strong>.</li></ul></li></ul><h6 id="第二个：介质定理"><a href="#第二个：介质定理" class="headerlink" title="第二个：介质定理"></a>第二个：介质定理</h6><ul><li><p>如果$m≤\mu≤M$，则在$[a,b]$内，一定存在$\xi$，使得$f(\xi)=\mu$.【连续函数能取到已知两个函数值之间的任意值】</p></li><li><p>介质定理的推论：若$m≤\mu≤M$，<font color='red'>则在$(a,b)$内</font>，存在$\xi$，使得$f(\xi)=\mu$.</p></li></ul><h6 id="第三个：平均值定理"><a href="#第三个：平均值定理" class="headerlink" title="第三个：平均值定理"></a>第三个：平均值定理</h6><ul><li>两种情况$\begin{cases}离散:f(\xi)=\frac{f(x_1)+f(x_2)+…+f(x_n)}{n},\xi∈[x_1,x_n]\连续:f(\xi)=\frac{\int_a^bf(x)dx}{b-a},\xi∈[a,b]或者\xi∈(a,b)\end{cases}$.</li></ul><h6 id="第四个：零点定理"><a href="#第四个：零点定理" class="headerlink" title="第四个：零点定理"></a>第四个：零点定理</h6><ul><li><p>零点定理：如果$f(a)*f(b)&lt;0$，则存在$\xi∈(a,b)$，使$\color{Red}f(\xi)=0$.</p><ul><li><p><strong>是介质定理的推论</strong>.</p><blockquote><p>$m≤0≤M$</p></blockquote></li><li><p>因为$f(a),f(b)≠0$，所以是开区间</p></li><li><p>推论：【与罗尔定理的推论类似】</p><p>$f(x)在(a,b)连续，lim_{}$</p></li></ul></li></ul><h5 id="2-f’-x-相关【注意连续】"><a href="#2-f’-x-相关【注意连续】" class="headerlink" title="2. $f’(x)$相关【注意连续】"></a>2. $f’(x)$相关【注意连续】</h5><h6 id="第五个：费马定理"><a href="#第五个：费马定理" class="headerlink" title="第五个：费马定理"></a>第五个：费马定理</h6><ul><li><p>费马定理：$\begin{cases}f(x)在(a,b)上可导\\xi为极值点\end{cases}\Longrightarrow f^{‘}(\xi)=0,\xi∈(a,b)$.$\color{Red}{^{【极值→区间内的最值】}}$</p><ul><li><p>证明：</p><blockquote><p>不妨设为极大值点，</p><p>$\begin{cases}f^{‘}<em>-(\xi)=lim</em>{x→\xi^-}\frac{f(x)-f(\xi)}{x-\xi}\stackrel{极大值+\color{Red}保号性}{\Longrightarrow}≤0\f^{‘}<em>+(\xi)=lim</em>{x→\xi^+}\frac{f(x)-f(\xi)}{x-\xi}\stackrel{极大值+保号性}{\Longrightarrow}≥0\end{cases}\stackrel{可导}{\Longrightarrow} f^{‘}(\xi)=0$</p></blockquote></li><li><p><strong>导数零点定理</strong>：$f(x)$在$(a,b)$内可导，若$f^{‘}(a^+)*f^{‘}(b^-)&lt;0$，则存在$\xi∈(a,b)$，使$f^{‘}(\xi)=0$【无需$f’(x)$连续】</p><blockquote><p>证明：</p><p>不妨设$f^{‘}(a^+)&lt;0,f^{‘}(b^-)&gt;0$</p><p>$\begin{cases}f^{‘}(a^+)=lim_{x→a^+}\frac{f(x)-f(a)}{x-a}&lt;0\stackrel{脱帽性}{\Longrightarrow}f(x)&lt;f(a)\f^{‘}(b^-)=lim_{x→b^-}\frac{f(x)-f(b)}{x-b}&gt;0\stackrel{脱帽性}{\Longrightarrow}f(x)&gt;f(b)\end{cases}\Longrightarrow f(a)和f(b)都不是最大值→$</p><p>$→最值在区间内部→极值\stackrel{可导}{→}f^{‘}(\xi)=0$</p></blockquote><ul><li>推广：$f’(x)≠0\Longrightarrow f’(x)保号$.</li></ul></li></ul></li></ul><h6 id="第六个：罗尔定理"><a href="#第六个：罗尔定理" class="headerlink" title="第六个：罗尔定理"></a>第六个：罗尔定理</h6><ul><li><p>罗尔定理：$\begin{cases}f(x)在(a,b)内可导\f(a)=f(b)\end{cases}\Longrightarrow f^{‘}(\xi)=0,\xi∈(a,b)$.</p><ul><li><p>证明：</p><blockquote><p>可导-由拉氏定理得：$f(b)-f(a)=f^{‘}(\xi)(b-a)=0$，因为$a≠b$，所以$f^{‘}(\xi)≠0$.</p><p>【罗尔定理是拉氏定理的特殊情况】</p><p>【几何角度解释】</p></blockquote></li><li><p>推广：</p><ul><li>$f(a)=f(b)=±\infty,a和b均为常数$.</li><li>$f(a)=f(b)=C,a和b有一个为\infty$.</li><li>$f(a)=f(b),a和b都为\infty$.</li></ul></li><li><p><font color='red'>构造辅助函数</font>：【因为一般不会直接给$f’(\xi)=0$，而是一个复杂的$F’(x)=0$，我们就需要用罗尔去证明$F(a)=F(b)$】$^{【与拉氏定理的关系】}$.</p><ul><li><p>见到：$2f(x)f’(x)\Longrightarrow F(x)=f^2(x)$，$F’(x)=0$.</p></li><li><p>见到：$f(x)f’’(x)+[f’(x)]^2$$\Longrightarrow F(x)=f(x)f’(x)$，$F’(x)=0$.</p></li><li><p><font color='red'>3见到：$f’(x)+f(x)\phi’(x)\Longrightarrow F(x)=f(x)e^{\phi(x)}$</font>.</p><ul><li><p>【$e^x$的原因：①求导不变性②恒正，不参与=0的工作】</p></li><li><p>【没有$\phi(x)$，因为被除掉了，只剩一个光棍$\phi’(x)$，所以想到$e^{\phi(x)}$；注意有时候$f(x)和\phi(x)$顺序会互换】</p></li><li><p><strong>常考：</strong></p><p>$f’(x)+f(x),\phi(x)=x$.</p><p>$f’(x)-f(x),\phi(x)=-x$.</p><p>$f’(x)+\lambda f(x),\phi(x)=\lambda x$.</p></li></ul></li><li><p>4见到：$f’(x)\phi(x)+f(x)\phi’(x)$，能直接看出来.</p></li><li><p>【3和4的区别在于：$f’(x)$是否还乘了东西】</p></li></ul></li><li><p>例题</p><ul><li><p>【例1.6.6】0-1套话，①已知$f(0)=f(1)=0$，$f(\frac{1}{2})=1$，证明存在$\eta∈(\frac{1}{2},1)$，使得$f(\eta)=\eta$.②证明$\exists \xi∈(0,\eta),f’(\xi)-\lambda[f(\xi)-\xi]=1$.</p><blockquote><p>【分析】：①$f(\eta)-\eta=0\rightarrow F(\eta)=0\stackrel{零点定理}{\rightarrow}F(\frac{1}{2})*F(1)&lt;0$.②$f’(\xi)-1-\lambda[f(\xi)-\xi]=0\rightarrow F’(\xi)=\big(f(\xi)-\xi\big)e^{-\lambda\xi}=0\stackrel{打卡锦囊，便是妙计}{—\rightarrow}f(\xi)-\xi=0$.</p></blockquote></li><li><p>【例1.6.7】设$f(x)$在$[0,3]$连续，$(0,3)$二阶可导，且$2f(0)=\int_0^2f(x)dx=f(2)+f(3)$.证明①$\exist\eta\in(0,2),make\ f(\eta)=f(0)$.②$\exist\xi\in(0,3),make\ f’’(\xi)=0$.</p><blockquote><p>【分析】：看条件，两个平均值定理都有了，而且不一个区间，很赞，山劈两半了①$2f(0)=\int_0^2f(x)dx\stackrel{连续平均值定理}{\longrightarrow}f(\eta)=f(0),\eta\in(0,2)$②$2f(0)=f(2)+f(3)\stackrel{离散平均值定理}{\longrightarrow}f(\tau)=f(0),\tau\in(2,3)\stackrel{f(\eta)=f(0)}{\rightarrow}f’(\xi_1)=0=f’(\xi_2),\xi_1\in(0,\eta),\xi_2\in(\eta,\tau)→f’’(\xi)=0,\xi\in(\xi_1,\xi_2)$.【画笑脸】</p></blockquote></li></ul></li></ul></li></ul><h6 id="第七个：拉氏中值定理"><a href="#第七个：拉氏中值定理" class="headerlink" title="第七个：拉氏中值定理"></a>第七个：拉氏中值定理</h6><ul><li><p><strong>拉格朗日中值定理：</strong>$[a,b]$连续，$(a,b)$可导$\Longrightarrow f(b)-f(a)=f’(\xi)(b-a),\color{Red}\xi∈(a,b)$.</p><ul><li><p>证明：</p><blockquote></blockquote></li><li><p>补充：</p><ul><li>存在切线斜率等于割线斜率</li><li><strong>云深不知处</strong>：$\xi$是端点$a,b$的函数</li></ul></li><li><p>应用：</p><ul><li>见到：$\begin{cases}f与f\f与f^{‘}\end{cases}\Longrightarrow$拉氏定理（/罗尔）</li><li>$\boldsymbol{f(x)=f(x)-f(0)}$.</li><li>$\boldsymbol{e^x-1=e^x-e^0}$.</li></ul></li><li><p>例题</p><ul><li><p>【例1.6.10】0-1套话，证明至少存在一点$\xi∈(0,1)$，使得$f(1)=3\xi^2f(\xi)+\xi^3f’(\xi)$.</p><blockquote><p>【分析】首先想到罗尔定理辅导函数，但$F’(\xi)=C\not=0$，所以用拉格朗日$^{【条件翻译】}$.</p></blockquote></li><li><p>【例1.6.11】0-1套话，且$f(0)=0,f(1)=1$，证明存在不同的$\xi_1,\xi_2∈(0,1),使\frac{1}{f’(\xi_1)}+\frac{1}{f’(\xi_2)}=2$.</p><blockquote><p>【分析】看到不同，劈山→$0&lt;\xi_1&lt;\tau&lt;\xi_2&lt;1$【一大串式子等于$C$→分母相同，分子字母相消】【命题套路，先弄一个第一问证明$f(\tau)=\frac{1}{2}$】</p></blockquote></li></ul></li></ul></li></ul><h6 id="第八个：柯西中值定理"><a href="#第八个：柯西中值定理" class="headerlink" title="第八个：柯西中值定理"></a>第八个：柯西中值定理</h6><ul><li><p>柯西中值定理：$[a,b]$连续，$(a,b)$可导，$g’(x)\not=0^{【有时候需要证明这个条件】}$，则$\exist \xi\in(a,b),make \frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi)}{g’(x)}$.</p><ul><li><p>证明不考，错误的证明方式如下：<del>直接用两个拉格朗日相除</del>。错误原因：云深不知处，两个$\xi$不一定一样.</p></li><li><p>因为前提条件太多，所以不容易考察（条件会很明显），因此常见考法如下：</p><p>一个抽象$f(x)$，一个具体$g(x)$.</p></li><li><p>例题：【例1.6.12】a-b套话，Prove $\exist \xi\in(a,b),\ make:f(b)-f(a)=\xi ln\frac{b}{a}f’(\xi)$.</p></li><li><p>与拉格朗日的关系【2020年真题，仅一次】</p><p>柯西$\stackrel{g(x)=x}{\Longrightarrow}$拉格朗日$\stackrel{b=a}{\Longrightarrow}$罗尔.</p></li></ul></li></ul><h6 id="第九个：泰勒公式"><a href="#第九个：泰勒公式" class="headerlink" title="第九个：泰勒公式"></a>第九个：泰勒公式</h6><ul><li><p><strong><font color='red'>泰勒公式【将$f(x)$在另一点$x_0$处展开】</font></strong></p><ul><li><p>带有拉格朗日余项的展开式：<font color='red'>在$x_0$的某邻域内</font>，</p><p>$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{1}{2!}f’’(x_0)(x-x_0)^2+…+\frac{1}{n!}f^n(x_0)(x-x_0)^n+\color{Orange}{\frac{1}{(n+1)!}f^{(n+1)}(\color{ed}\xi)(x-x_0)^{(n+1)}}$，前n项为精确项，最后一个为拉格朗日余项，<font color='red'>$\xi 介于x,x_0之间$.【没有说$x_0和x的大小$】，区间</font>.</p></li><li><p>带有佩亚诺余项的展开式：<font color='red'>当$x\rightarrow x_0$</font>，</p><p>$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{1}{2!}f’’(x_0)(x-x_0)^2+…+\frac{1}{n!}f^n(x_0)(x-x_0)^n+\color{Orange}{o((x-x_0)^n)}$.<font color='red'>局部，用于极限计算</font>.$^{【第一讲常用泰勒公式】}$.</p></li><li><p>例题</p><ul><li><p>【例1.6.13】$f(x)$在区间$[-a,a]$上有二阶连续导数，$f(0)=0$，①写出$f(x)$的带拉格朗日余项的一阶麦克劳林公式②证明$\exists \eta\in[-a,a],使a^3f’’(\eta)=\int_{-a}^af(x)dx$.</p><blockquote><p>.</p></blockquote></li><li><p>【例】设$f(x)$在$x=x_0$处二阶可导，$f’(x_0)=0$且$f’’(x_0)&lt;0$，证明：$f(x)$在$x=x_0$处取极大值$^{【真题考研思路：展开一项一项搞】}$</p></li></ul></li><li><p><strong>重要关系</strong>：</p><p>  <img src="http://jallery.oss-cn-beijing.aliyuncs.com/_posts/image-20200331104538635.png" alt="image-20200331104538635">.</p></li></ul></li></ul><h6 id="第十个：积分中值定理"><a href="#第十个：积分中值定理" class="headerlink" title="第十个：积分中值定理"></a>第十个：积分中值定理</h6><ul><li><p>积分中值定理：$\begin{cases}\int_a^bf(x)dx=\color{Red}{f(\xi)}(b-a),\xi∈[a,b]\\int_a^bf(x)dx=\color{Red}{f(\xi)}(b-a),\xi∈(a,b),可直接使用，无需证明\end{cases}$.【注意是$f(\xi)$，而非导数】【证明思路：<strong>常量变量化</strong>】【虽说没有$f’(x)$的形式，但因为$F’(x)=f(x)$，所以放在这里】</p><ul><li><p>”第二个加强形式的积分中值定理“证明：</p><p>令$F(x)=\int_a^xf(t)dt$，在$[a,b]$上使用拉格朗日定理，有$F(b)-F(a)=F’(\xi)(b-a)$，则$\int_a^bf(x)dx-0=f(\xi)(b-a),\xi\in(a,b)$.</p></li></ul></li></ul><h5 id="3-中值定理总结："><a href="#3-中值定理总结：" class="headerlink" title="3. 中值定理总结："></a>3. 中值定理总结：</h5><ul><li>只要需要用$f(a)$的公式，都需要是闭区间$[a,b]$，如介质定理，离散的平均值定理，罗尔定理，拉氏定理，柯西中值定理.</li><li>只要能用极限代替端点值的公式，都可以用开区间$(a,b)$，如连续的平均值定理$^{定积分定义中有极限}$，积分中值定理.</li></ul><h5 id="3-微分等式问题（方程的根，函数零点）"><a href="#3-微分等式问题（方程的根，函数零点）" class="headerlink" title="3. 微分等式问题（方程的根，函数零点）"></a>3. 微分等式问题（方程的根，函数零点）</h5><h5 id="4-微分不等式问题"><a href="#4-微分不等式问题" class="headerlink" title="4. 微分不等式问题"></a>4. 微分不等式问题</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/"/>
    <url>/2020/10/11/%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h4 id="一、不定积分"><a href="#一、不定积分" class="headerlink" title="一、不定积分"></a>一、不定积分</h4><h5 id="1-概念，定义"><a href="#1-概念，定义" class="headerlink" title="1. 概念，定义"></a>1. 概念，定义</h5><h6 id="1-1-原函数（不定积分）存在定理"><a href="#1-1-原函数（不定积分）存在定理" class="headerlink" title="1.1 原函数（不定积分）存在定理"></a>1.1 原函数（不定积分）存在定理</h6><ul><li>函数$f(x)$在$[a,b]$上连续，则在区间$[a,b]$上存在原函数$F(x)+C$，具体形式为$\int_a^xf(t)dt+C=\int f(x)dx$.【当$a$确定时，$\int_a^xf(t)dt$确定了，所以不能再加$C$，即不能表示所有爸】【函数有爸，则有无数个爸，且差C】</li><li>含有第一类间断点，无穷间断点的函数$f(x)$在<strong>包含该点的区间</strong>内无原函数$F(x)$.<font color='0779e4'>【例1.1.1】</font>.【<strong>多次考到</strong>】</li></ul><a id="more"></a><h6 id="1-2-原函数的性质"><a href="#1-2-原函数的性质" class="headerlink" title="1.2 原函数的性质"></a>1.2 原函数的性质</h6><ul><li><p>$F(x)$在区间$[a,b]$上任意一点都有$F’(x)=f(x)$.</p></li><li><p>$(\int_0^{\phi(x)}f(t)dt)’=f(\phi(x))\phi’(x)$，不要把$\phi’(x)$丢了！！</p></li><li><p>奇偶周期性</p><ul><li><p>$\int_a^xf(t)dt=F(x)+C—–f(x)———f’(x)$.</p><p>$偶函数————奇函数———偶函数$.</p><p>$奇函数\stackrel{a=0时}{————}偶函数———奇函数$.</p><p>$T\stackrel{\int_0^Tf(t)dt=0时}{————–}T———–T$.</p><blockquote><p>34年没考过偶函数且$a=0$时的爸</p></blockquote></li><li><p>偶函数在对称区间上的积分可以化为“2×一般区间积分”</p></li><li><p><font color='red'>奇函数在对称区间上的积分为0！【有时很麻烦的三角函数可以直接=0】</font>.</p></li></ul></li></ul><h6 id="1-3-变限积分存在定理"><a href="#1-3-变限积分存在定理" class="headerlink" title="1.3 变限积分存在定理"></a>1.3 变限积分存在定理</h6><ul><li><p>若$f(x)$在$[a,b]$上有有限个第一类间断点(设为$x_1,x_2…x_n$)，则在$[a,b]$上存在变限积分$F(x)=\int_c^xf(t)dt$【注意，不是原函数】，且不论$c$是否等于$x_i$：</p><ul><li>$F(x)$在$[a,b]$上连续</li><li>$F’(x)=(\int_a^xf(t)dt)’=f(x)$，当$x\not=x_1,x_2…x_n$.</li><li>$F_-‘(x)=f(x_0^-),F_+’(x)=f(x_0^+)$.</li></ul></li><li><p><font color='0779e4'>【例1.1.1】</font>设$f(x)=\begin{cases}e^x,x&lt;0\x,x≥0\end{cases},F(x)=\int_1^xf(t)dt$，则$F(x)$在$x=0$处：</p><p>A）极限不存在  B）极限存在但不连续  C）连续但不可导   D）可导，且$F’(0)=0$</p><blockquote><p>在定义域内没有原函数，连续→该点出极限存在，$F’<em>-(0)=f(0^-)=lim</em>{x→0^-}f(x)=1,F’_+(0)=f(0^+)=0$，选C</p></blockquote></li></ul><h5 id="2-四大积分法"><a href="#2-四大积分法" class="headerlink" title="2. 四大积分法"></a>2. 四大积分法</h5><h6 id="2-1-凑微分法"><a href="#2-1-凑微分法" class="headerlink" title="2.1 凑微分法"></a>2.1 凑微分法</h6><ul><li>$\int g[f(x)]f’(x)dx=\int g[f(x)]df(x)【\stackrel{令t=f(x)}{===}\int g(t)dt】$.</li><li>常见解题情况<ul><li>有理分式$\frac{P_n(x)}{Q_m(x)}$的分母上有单独的$x^{n-1}$，则积分变量处配为$dx^n$【可以配出任意阶！！】【注，积分变量仍为$x$！】</li><li>解有理分式，分子为$Ax+B$，分母有$ax^2+bx+c$时，将分子配出$\frac{1}{\alpha}(2ax+b)+\beta$，然后拆开将第一项凑微分【注，分子不要配成这样$2ax+b-(A-2a)x+(B-b)$，这样就更复杂了，因为拆分后因式更不能积分】</li></ul></li></ul><h6 id="2-2-换元法"><a href="#2-2-换元法" class="headerlink" title="2.2 换元法"></a>2.2 换元法</h6><ul><li>普通换元（幂函数换元）【前提是凑微分】<ul><li>如：令$t=x^2、t=x^2+1$.</li></ul></li><li><h2 id="倒代换"><a href="#倒代换" class="headerlink" title="倒代换"></a>倒代换</h2></li><li>三角换元<ul><li>$\sqrt{a^2-x^2}\stackrel{令x=asint}{====}acost$，【注意换积分变量，定积分是换上下限】【令$x=acost$其实也可以】<font color='0779e4'>【全书P94】【660-56】</font>.</li><li>$\sqrt{a^2+x^2}\stackrel{令x=atant}{====}a\frac{1}{cost}$.<font color='0779e4'>【全书P97】</font>.</li></ul></li><li>根式换元<ul><li>当根号下是一般二次因式$\sqrt{ax^2+bx+c}$时，一般可以尝试将其配成平方差公式/平方和公式，然后三角换元</li><li>当有$\sqrt[m]{ax+b}$和$\sqrt[n]{cx+d}$时，令$t=\sqrt[l]{ex+f},l是m和n的最小公倍数$，</li><li>有$\sqrt{\frac{ax+b}{cx+d}}$时，直接令$t=\sqrt{\frac{ax+b}{cx+d}}$，然后解出$x$【或者尝试乘以分子之后拆开，接下来看能否直接用公式/凑微分等基础工具！】【注，换元之后一般可以凑微分！！！】</li></ul></li><li>换元之后记得回代！！！</li></ul><h6 id="2-3-分部积分法"><a href="#2-3-分部积分法" class="headerlink" title="2.3 分部积分法"></a>2.3 分部积分法</h6><ul><li><p>$\int uv’=\int udv=uv-\int vdu$，$f(x)和g(x)$通常是不同类型的函数【一般先要凑微分】</p><ul><li>反对幂指三/三指，<ul><li>前面的是$u$，后放，求导【求导是对分部之后的积分形式来说的】</li><li>三指/指三可以互换，因为是积分再现</li></ul></li><li>$f(x)和g(x)$也可以是不同类型的函数，<strong>如都是有理因式</strong>：</li><li>并不是所有的不同类型函数相乘都可以用“分部积分”，有时只需用“凑微分”<font color='0779e4'>【例1.2.1】【例1.2.2】</font>.</li></ul></li><li><p>被积函数中含有<strong>导数或变限函数</strong>时，有时可以用分部积分</p></li><li><p>积分表【交叉相乘，正负相间】</p><ul><li>反对幂指三，先点到谁，先写谁</li><li>积分表长度的选择<ul><li>如果幂求导，则一般是幂求导至0</li><li>如果对求导，则一般至$\frac{1}{x}$.</li></ul></li></ul></li><li><p>例题</p><ul><li><p><font color='0779e4'>【例1.2.1】</font>求$\int{\frac{x^2+1}{x(x-1)^2}}lnxdx$.</p></li><li><p><font color='0779e4'>【例1.2.2】</font>求$\int e^x(\frac{1-x}{1+x^2})^2dx$.</p><blockquote><p>中间一步，要对$e^x$求导，而非幂函数</p></blockquote></li></ul></li></ul><h6 id="2-4-有理函数积分法"><a href="#2-4-有理函数积分法" class="headerlink" title="2.4 有理函数积分法"></a>2.4 有理函数积分法</h6><ul><li>常见拆解法<ul><li>分母的一次因式$ax+b\rightarrow\frac{A}{ax+b}$.</li><li>分母的2重一次因式$(ax+b)^2\rightarrow\frac{A}{ax+b}+\frac{Bx+C}{(ax+b)^2}$.</li><li>分母的二次因式$ax^2+bx+c\rightarrow \frac{Ax+B}{ax^2+bx+c}$.</li><li>分母的k重二次因式$(ax^2+bx+c)^k\rightarrow \frac{Ax+B}{ax^2+bx+c}+\frac{Cx+D}{(ax^2+bx+c)^2}+…+\frac{Mx+N}{(ax^2+bx+c)^k}$.</li></ul></li><li>有理函数积分的目的是<font color='red'>拆分之后容易积分，或可以使用简单的凑微分/换元积分</font>，如果拆分之后的因式不能积分，则可能需要放弃此法</li><li>并不是所有的有理函数都需要这样拆分，有的时候可以直接看着分母凑分子？</li><li>有的有理函数本身就是最简因式，不需要再拆分，因为拆分之后还是自己，如$\frac{x+1}{(1+x^2)^2}$.</li></ul><h6 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h6><ul><li>从上面四大积分法，其实可以看出，换元法之后可能用到“凑微分”；分部积分之后可能用到“换元法”和“凑微分”；有理函数积分则更经常用到“凑微分”和“换元”，有时还会用到”分部积分“。</li></ul><h4 id="3-倒三角"><a href="#3-倒三角" class="headerlink" title="3. 倒三角"></a>3. 倒三角</h4><ul><li>三角因式</li></ul><h4 id="二、定积分"><a href="#二、定积分" class="headerlink" title="二、定积分"></a>二、定积分</h4><h5 id="1-概念、性质、定理"><a href="#1-概念、性质、定理" class="headerlink" title="1. 概念、性质、定理"></a>1. 概念、性质、定理</h5><h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><ul><li><font color='red'>$lim_{n→\infty}\sum_{i=1}^n f(\frac{i}{n})\frac{1}{n}=\int_0^1f(x)dx$</font>【 ①提出$\frac{1}{n}$②凑出$\frac{i}{n}$③写出$\int_0^1f(d)dx$】</li></ul><h6 id="1-1-定积分存在定理【不是重点，不怎么考】"><a href="#1-1-定积分存在定理【不是重点，不怎么考】" class="headerlink" title="1.1 定积分存在定理【不是重点，不怎么考】"></a>1.1 定积分存在定理【不是重点，不怎么考】</h6><ul><li><p>充分条件</p><ul><li><p>函数$f(x)$在$[a,b]$上连续，则存在定积分$\int_a^b{f(x)dx}$.</p></li><li><p>函数$f(x)$在$[a,b]$上<strong>有界</strong>且有有限个<strong>第一类间断点</strong>【无穷间断？】，则存在定积分$\int_a^b{f(x)dx}$.</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200520113706058.png" alt="image-20200520113706058"></p></li></ul></li><li><p>必要条件</p><ul><li>可积函数必有界</li></ul></li></ul><h6 id="1-2-四大性质"><a href="#1-2-四大性质" class="headerlink" title="1.2 四大性质"></a>1.2 四大性质</h6><ul><li><p>求区间长度，$\int_a^bdx=b-a$.</p></li><li><p>积分的线性性质</p></li><li><p>积分的可加/可拆行</p></li><li><p>保号性</p><ul><li><p>$f(x)≤g(x)$，则$\int_a^bf(x)dx≤\int g(x)dx$</p><blockquote><p>如果积分取等号，则函数恒等</p></blockquote></li></ul></li><li><p>估值定理（没考过）</p></li><li><p><font color='red'>中值定理</font>：设$f(x)在[a,b]$上连续，则$\exist\xi\in[a,b]$，使得$\int_a^bf(d)dx=f(\xi)(b-a)$.</p><blockquote><p>证明：令$F(x)=\int_a^xf(t)dt\stackrel{拉氏}{→}F(b)-F(a)=F’(\xi)(b-a)$.</p><p>​            所以$\int_a^bf(x)dx=f(\xi)(b-a)$，$\xi\in(a,b)\in[a,b]$。</p></blockquote><p><strong>抽象函数的定积分则使用</strong>。</p><ul><li>可搞二阶导的定理：<ul><li>拉氏</li><li>三次罗尔</li><li>一次泰勒</li></ul></li></ul></li></ul><h5 id="2-区间再现公式"><a href="#2-区间再现公式" class="headerlink" title="2. 区间再现公式"></a>2. 区间再现公式</h5><ul><li><p>$\int_a^bf(x)dx=\int_a^bf(a+b-x)dx$.【常用于三角函数的积分】</p><ul><li><p>$\int_{a}^bf(x)dx=\int_a^{\frac{a+b}{2}}{[f(x)+f(a+b-x)]}$，</p><p>【特殊的，对称区间时，常用这个变形公式，因为$a+b=0$，计算简单<font color='0779e4'>【全书P100】</font>】</p></li></ul></li></ul><h5 id="3-华里士公式"><a href="#3-华里士公式" class="headerlink" title="3. 华里士公式"></a>3. 华里士公式</h5><ul><li><p>$\int_0^{\frac{\pi}{2}}sin^nx=\int_0^{\frac{\pi}{2}}cos^nx=\begin{cases}\frac{n-1}{n}<em>\frac{n-3}{n-2}</em>…<em>\frac{1}{2}*\frac{\pi}{2}[点火成功]\\frac{n-1}{n}*\frac{n-3}{n-2}</em>…*\frac{2}{3}\end{cases}$.【年年考】</p></li><li></li></ul><h5 id="3-抽象函数定积分"><a href="#3-抽象函数定积分" class="headerlink" title="3. 抽象函数定积分"></a>3. 抽象函数定积分</h5><ul><li>中值定理</li></ul><h4 id="三、积分的几何应用"><a href="#三、积分的几何应用" class="headerlink" title="三、积分的几何应用"></a>三、积分的几何应用</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E7%BD%91%E7%AB%99%E5%B0%8F%E6%8F%92%E4%BB%B6/"/>
    <url>/2020/10/11/%E7%BD%91%E7%AB%99%E5%B0%8F%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>cover:  img/1.jpg</p><hr><p>参考资料：</p><ul><li><a href="http://www.jq22.com/daima269">JQuery</a></li></ul><p>Demo</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;canvas&quot;</span>&gt;</span>  Your browser doesn&#x27;t support canvas features.<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="鼠标轨迹——彩色小球"><a href="#鼠标轨迹——彩色小球" class="headerlink" title="鼠标轨迹——彩色小球"></a>鼠标轨迹——彩色小球</h4><a id="more"></a><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span>body,&#123;  margin: 0;  padding: 0;  border: 0;  font-family: &#x27;Nunito&#x27;, sans-serif;&#125;canvas&#123;  margin: 0;  padding: 0;<span class="css">  <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">block</span>; <span class="hljs-comment">/*  ¯\_(ツ)_/¯  */</span></span>  touch-action: none;&#125;h1&#123;  position: absolute;  top: 50%;  left: 0;  margin: auto;  width: 100%;  text-align: center;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;canvas&#x27;</span>);</span>canvas.height = 100;<span class="javascript">canvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><span class="javascript">c = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);</span><span class="javascript"><span class="hljs-comment">//窗口大小改变是重新设置canvas大小</span></span><span class="javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span>    canvas.height = 100;<span class="javascript">    canvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span>    initCanvas();&#125;)<span class="javascript"><span class="hljs-keyword">var</span> mouse = &#123;</span><span class="javascript">    x: <span class="hljs-literal">undefined</span>,</span><span class="javascript">    y: <span class="hljs-literal">undefined</span></span>&#125;<span class="javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>,</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span>        mouse.x = event.offsetX;        mouse.y = event.offsetY;        drawCircles();    &#125;)<span class="javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;touchmove&quot;</span>,</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">let</span> touch = event.touches[<span class="hljs-number">0</span>];</span>        mouse.x = touch.clientX;        mouse.y = touch.clientY;        drawCircles();    &#125;)<span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">x, y, radius, vx, vy, rgb, opacity, birth, life</span>)</span>&#123;</span><span class="javascript">    <span class="hljs-built_in">this</span>.x = x;</span><span class="javascript">    <span class="hljs-built_in">this</span>.y = y;</span><span class="javascript">    <span class="hljs-built_in">this</span>.radius = radius;</span><span class="javascript">    <span class="hljs-built_in">this</span>.minRadius = radius;</span><span class="javascript">    <span class="hljs-built_in">this</span>.vx = vx;</span><span class="javascript">    <span class="hljs-built_in">this</span>.vy = vy;</span><span class="javascript">    <span class="hljs-built_in">this</span>.birth = birth;</span><span class="javascript">    <span class="hljs-built_in">this</span>.life = life;</span><span class="javascript">    <span class="hljs-built_in">this</span>.opacity = opacity;</span><span class="javascript">    <span class="hljs-built_in">this</span>.draw = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span>        c.beginPath();<span class="javascript">        c.arc(<span class="hljs-built_in">this</span>.x, <span class="hljs-built_in">this</span>.y, <span class="hljs-built_in">this</span>.radius, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);</span><span class="javascript">        c.fillStyle = <span class="hljs-string">&#x27;rgba(&#x27;</span> + rgb +<span class="hljs-string">&#x27;,&#x27;</span>+ <span class="hljs-built_in">this</span>.opacity +<span class="hljs-string">&#x27;)&#x27;</span>;</span>        c.fill();    &#125;<span class="javascript">    <span class="hljs-built_in">this</span>.update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.radius &gt; innerWidth || <span class="hljs-built_in">this</span>.x - <span class="hljs-built_in">this</span>.radius &lt; <span class="hljs-number">0</span>) &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.vx = -<span class="hljs-built_in">this</span>.vx;</span>        &#125;<span class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.y + <span class="hljs-built_in">this</span>.radius &gt; innerHeight || <span class="hljs-built_in">this</span>.y - <span class="hljs-built_in">this</span>.radius &lt; <span class="hljs-number">0</span>) &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.vy = -<span class="hljs-built_in">this</span>.vy;</span>        &#125;<span class="javascript">        <span class="hljs-built_in">this</span>.x += <span class="hljs-built_in">this</span>.vx;</span><span class="javascript">        <span class="hljs-built_in">this</span>.y += <span class="hljs-built_in">this</span>.vy;</span><span class="javascript">        <span class="hljs-built_in">this</span>.opacity = <span class="hljs-number">1</span>- (((frame - <span class="hljs-built_in">this</span>.birth) * <span class="hljs-number">1</span>) / <span class="hljs-built_in">this</span>.life);</span><span class="javascript">        <span class="hljs-keyword">if</span> (frame &gt; <span class="hljs-built_in">this</span>.birth + <span class="hljs-built_in">this</span>.life)&#123;</span><span class="javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; circleArray.length; i++)&#123;</span><span class="javascript">                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.birth == circleArray[i].birth &amp;&amp; <span class="hljs-built_in">this</span>.life == circleArray[i].life)&#123;</span>                    circleArray.splice(i, 1);<span class="javascript">                    <span class="hljs-keyword">break</span>;</span>                &#125;            &#125;<span class="javascript">        &#125; <span class="hljs-keyword">else</span>&#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.draw();</span>        &#125;    &#125;&#125;<span class="javascript"><span class="hljs-keyword">var</span> circleArray = [];</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initCanvas</span>(<span class="hljs-params"></span>) </span>&#123;</span>    circleArray = [];&#125;<span class="javascript"><span class="hljs-keyword">var</span> colorArray = [</span><span class="javascript">    <span class="hljs-string">&#x27;355,85,80&#x27;</span>,</span><span class="javascript">    <span class="hljs-string">&#x27;9,80,100&#x27;</span>,</span><span class="javascript">    <span class="hljs-string">&#x27;343,81,45&#x27;</span></span>]<span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawCircles</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;</span><span class="javascript">        <span class="hljs-keyword">let</span> radius = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">4</span>) + <span class="hljs-number">2</span>;</span><span class="javascript">        <span class="hljs-keyword">let</span> vx = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;</span><span class="javascript">        <span class="hljs-keyword">let</span> vy = (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;</span><span class="javascript">        <span class="hljs-keyword">let</span> spawnFrame = frame;</span><span class="javascript">        <span class="hljs-keyword">let</span> rgb = colorArray[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colorArray.length)];</span><span class="javascript">        <span class="hljs-keyword">let</span> life = <span class="hljs-number">100</span>;</span><span class="javascript">        circleArray.push(<span class="hljs-keyword">new</span> Circle(mouse.x, mouse.y, radius, vx, vy, rgb, <span class="hljs-number">1</span>, spawnFrame, life));</span>    &#125;&#125;<span class="javascript"><span class="hljs-keyword">var</span> frame = <span class="hljs-number">0</span>;</span><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>&#123;</span>    requestAnimationFrame(animate);    frame += 1;    c.clearRect(0, 0, innerWidth, innerHeight);<span class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; circleArray.length; i++ )&#123;</span>        circleArray[i].update();    &#125;&#125;initCanvas();animate();<span class="javascript"><span class="hljs-comment">// This is just for demo purposes :</span></span><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">110</span>; i++) &#123;</span><span class="javascript">    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span>            mouse.x = 100 + i * 10;            mouse.y = 100;            drawCircles();         &#125;, i * 10);    &#125;)(i);&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="鼠标轨迹——旋转线条"><a href="#鼠标轨迹——旋转线条" class="headerlink" title="鼠标轨迹——旋转线条"></a>鼠标轨迹——旋转线条</h4><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Canvas Resize<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span>        html,        body &#123;            margin: 0;            overflow: auto;<span class="css">            <span class="hljs-selector-tag">overflow-x</span><span class="hljs-selector-pseudo">:hidden</span></span>        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">canvas</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span>    /**     * 辅助函数     */<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomIntFromRange</span>(<span class="hljs-params">low, high</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (high - low + <span class="hljs-number">1</span>) + low);</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomDoubleFromRange</span>(<span class="hljs-params">low, high</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() * (high - low + <span class="hljs-number">1</span>) + low;</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randomColors</span>(<span class="hljs-params">colors</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">return</span> colors[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * colors.length)];</span>    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDistance</span>(<span class="hljs-params">x1, y1, x2, y2</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-keyword">let</span> dx = x1 - x2;</span><span class="javascript">        <span class="hljs-keyword">let</span> dy = y1 - y2;</span><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(dx * dx + dy * dy);</span>    &#125;    /**     * 颜色数组     */<span class="javascript">    <span class="hljs-keyword">let</span> colorArray = [</span><span class="javascript">        <span class="hljs-string">&#x27;#97A7F8&#x27;</span>,</span><span class="javascript">        <span class="hljs-string">&#x27;#C957CA&#x27;</span>,</span><span class="javascript">        <span class="hljs-string">&#x27;#76E2FE&#x27;</span>,</span>    ];    /**     * 鼠标位置     */<span class="javascript">    <span class="hljs-keyword">let</span> mouse = &#123;</span><span class="javascript">        x: <span class="hljs-built_in">window</span>.innerWidth / <span class="hljs-number">2</span>,</span><span class="javascript">        y: <span class="hljs-built_in">window</span>.innerHeight / <span class="hljs-number">2</span></span>    &#125;    /**     * 事件监听     */<span class="javascript">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span>        mouse.x = event.offsetX;        mouse.y = event.offsetY;    &#125;);<span class="javascript">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        canvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><span class="javascript">        canvas.height = <span class="hljs-built_in">window</span>.innerHeight;</span>        init();    &#125;);    /**     * 绘图部分     */<span class="javascript">    <span class="hljs-keyword">let</span> canvas = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;canvas&#x27;</span>);</span><span class="javascript">    canvas.width = <span class="hljs-built_in">window</span>.innerWidth;</span><span class="javascript">    canvas.height = <span class="hljs-built_in">window</span>.innerHeight;</span><span class="javascript">    <span class="hljs-keyword">let</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Particle</span>(<span class="hljs-params">x, y, radius, color</span>) </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">this</span>.x = x;</span><span class="javascript">        <span class="hljs-built_in">this</span>.y = y;</span><span class="javascript">        <span class="hljs-built_in">this</span>.radius = radius;</span><span class="javascript">        <span class="hljs-built_in">this</span>.color = color;</span><span class="javascript">        <span class="hljs-built_in">this</span>.theta = randomDoubleFromRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI);</span><span class="javascript">        <span class="hljs-built_in">this</span>.speed = <span class="hljs-number">0.05</span>;</span><span class="javascript">        <span class="hljs-built_in">this</span>.distance = randomIntFromRange(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>);</span><span class="javascript">        <span class="hljs-built_in">this</span>.dragSpeed = <span class="hljs-number">0.05</span>;</span><span class="javascript">        <span class="hljs-built_in">this</span>.lastMouse = &#123;</span>            x: x,            y: y        &#125;;<span class="javascript">        <span class="hljs-built_in">this</span>.draw = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">lastPosition</span>) </span>&#123;</span>            ctx.beginPath();<span class="javascript">            ctx.strokeStyle = <span class="hljs-built_in">this</span>.color;</span><span class="javascript">            ctx.lineWidth = <span class="hljs-built_in">this</span>.radius;</span>            ctx.moveTo(lastPosition.x, lastPosition.y);<span class="javascript">            ctx.lineTo(<span class="hljs-built_in">this</span>.x, <span class="hljs-built_in">this</span>.y);</span>            ctx.stroke();            ctx.closePath();        &#125;<span class="javascript">        <span class="hljs-built_in">this</span>.update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> lastPosition = &#123;</span><span class="javascript">                x: <span class="hljs-built_in">this</span>.x,</span><span class="javascript">                y: <span class="hljs-built_in">this</span>.y</span>            &#125;<span class="javascript">            <span class="hljs-comment">// 拖拽效果</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.lastMouse.x += (mouse.x - <span class="hljs-built_in">this</span>.lastMouse.x) * <span class="hljs-built_in">this</span>.dragSpeed;</span><span class="javascript">            <span class="hljs-built_in">this</span>.lastMouse.y += (mouse.y - <span class="hljs-built_in">this</span>.lastMouse.y) * <span class="hljs-built_in">this</span>.dragSpeed;</span><span class="javascript">            <span class="hljs-built_in">this</span>.x = <span class="hljs-built_in">this</span>.lastMouse.x + <span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">this</span>.theta) * <span class="hljs-built_in">this</span>.distance;</span><span class="javascript">            <span class="hljs-built_in">this</span>.y = <span class="hljs-built_in">this</span>.lastMouse.y + <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.theta) * <span class="hljs-built_in">this</span>.distance;</span><span class="javascript">            <span class="hljs-built_in">this</span>.theta += <span class="hljs-built_in">this</span>.speed;</span><span class="javascript">            <span class="hljs-built_in">this</span>.draw(lastPosition);</span>        &#125;    &#125;<span class="javascript">    <span class="hljs-keyword">let</span> particles;</span><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>&#123;</span>        particles = [];<span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> color = randomColors(colorArray);</span><span class="javascript">            particles.push(<span class="hljs-keyword">new</span> Particle(canvas.width / <span class="hljs-number">2</span>, canvas.height / <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, color));</span>        &#125;    &#125;<span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params"></span>) </span>&#123;</span>        requestAnimationFrame(animate);<span class="javascript">        <span class="hljs-comment">// 每一帧都给之前的帧蒙上一层白色透明的矩形</span></span><span class="javascript">        ctx.fillStyle = <span class="hljs-string">&#x27;rgba(255, 255, 255, 0.1)&#x27;</span>;</span>        ctx.fillRect(0, 0, canvas.width, canvas.height);<span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> p <span class="hljs-keyword">of</span> particles) &#123;</span>            p.update();        &#125;    &#125;    init();    animate();    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="HTML-CSS-JS合并为HTML格式："><a href="#HTML-CSS-JS合并为HTML格式：" class="headerlink" title="HTML+CSS+JS合并为HTML格式："></a>HTML+CSS+JS合并为HTML格式：</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">dir</span>=<span class="hljs-string">&quot;ltr&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css">        <span class="hljs-comment">/*复制CSS文件的代码*/</span></span>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;spinner&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">          <span class="hljs-comment">/*复制JS文件的代码*/</span></span>      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h4 id="鼠标点击–小猪"><a href="#鼠标点击–小猪" class="headerlink" title="鼠标点击–小猪"></a>鼠标点击–小猪</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://blog-static.cnblogs.com/files/wiggin-Z/mouse-click.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="鼠标点击–爆炸"><a href="#鼠标点击–爆炸" class="headerlink" title="鼠标点击–爆炸"></a>鼠标点击–爆炸</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="鼠标轨迹–星星"><a href="#鼠标轨迹–星星" class="headerlink" title="鼠标轨迹–星星"></a>鼠标轨迹–星星</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;js-cursor-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://blog-static.cnblogs.com/files/wiggin-Z/mouse-follow.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>注意，和”小猪”不同的是，第一行span的标签不能删掉，否则无效</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>js插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%81%E6%98%8E/"/>
    <url>/2020/10/11/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%81%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h4 id="一、统计"><a href="#一、统计" class="headerlink" title="一、统计"></a>一、统计</h4><h5 id="1-分布"><a href="#1-分布" class="headerlink" title="1. 分布"></a>1. 分布</h5><h6 id="1-1-两个独立泊松分布相加"><a href="#1-1-两个独立泊松分布相加" class="headerlink" title="1.1 两个独立泊松分布相加"></a>1.1 两个独立泊松分布相加</h6><ul><li>公式：已知$X$<del>$P(\lambda_1)$，$Y$</del>$P(\lambda_2)$，则$X+Y$~$P(\lambda_1+\lambda_2)$.</li><li>证明</li></ul><h5 id="1-frac-n-1-s-2-sigma-2-服从-chi-2-n-1"><a href="#1-frac-n-1-s-2-sigma-2-服从-chi-2-n-1" class="headerlink" title="1. $\frac{(n-1)s^2}{\sigma^2}服从\chi^2(n-1)$."></a>1. $\frac{(n-1)s^2}{\sigma^2}服从\chi^2(n-1)$.</h5><p><a href="https://www.jianshu.com/p/7dccb45ee9b3">(n-1)*样本方差/σ^2 服从自由度为 n-1 的卡方分布的证明</a>.</p><h5 id="2-样本方差与总体方差的关系式"><a href="#2-样本方差与总体方差的关系式" class="headerlink" title="2. 样本方差与总体方差的关系式"></a>2. 样本方差与总体方差的关系式</h5><p><a href="https://www.jianshu.com/p/12965d5dd56f">总体方差与样本方差</a>.</p><h5 id="3-二项分布推泊松分布"><a href="#3-二项分布推泊松分布" class="headerlink" title="3. 二项分布推泊松分布"></a>3. 二项分布推泊松分布</h5><p><a href="https://www.jianshu.com/p/f05e8f6288c9">中心极限定理证明</a>.</p><h5 id="4-两个样本均值之差的方差"><a href="#4-两个样本均值之差的方差" class="headerlink" title="4. 两个样本均值之差的方差"></a>4. 两个样本均值之差的方差</h5><p>概率论P57</p><h5 id="5-两独立样本t检验的估计误差"><a href="#5-两独立样本t检验的估计误差" class="headerlink" title="5. 两独立样本t检验的估计误差"></a>5. 两独立样本t检验的估计误差</h5><p><a href="https://zhuanlan.zhihu.com/p/44580486">两独立样本t检验</a>.</p><h4 id="二、回归"><a href="#二、回归" class="headerlink" title="二、回归"></a>二、回归</h4><h5 id="1-相关性"><a href="#1-相关性" class="headerlink" title="1. 相关性"></a>1. 相关性</h5><h6 id="1-1-相关系数r公式推导"><a href="#1-1-相关系数r公式推导" class="headerlink" title="1.1 相关系数r公式推导"></a>1.1 相关系数r公式推导</h6><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200615160909366.png" alt="image-20200615160909366"></p><h6 id="1-2-SST-SSR-SSE的两种证明思路"><a href="#1-2-SST-SSR-SSE的两种证明思路" class="headerlink" title="1.2 SST=SSR+SSE的两种证明思路"></a>1.2 SST=SSR+SSE的两种证明思路</h6><blockquote><p>SSR和SSE的称呼</p></blockquote><blockquote><p>证明用到的一些公式</p><ul><li>1</li><li>2</li></ul></blockquote><ul><li>思路一：拆分SST，</li><li>思路二：全拆</li></ul><h6 id="1-3-相关系数和-R-2-的关系"><a href="#1-3-相关系数和-R-2-的关系" class="headerlink" title="1.3 相关系数和$R^2$的关系"></a>1.3 相关系数和$R^2$的关系</h6><p><a href="https://www.zhihu.com/question/32021302/answer/739464752">相关系数和$R^2$的关系</a>.</p><h5 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2. 线性回归"></a>2. 线性回归</h5><h6 id="2-1-beta-的最小二乘估计公式"><a href="#2-1-beta-的最小二乘估计公式" class="headerlink" title="2.1 $\beta$的最小二乘估计公式"></a>2.1 $\beta$的最小二乘估计公式</h6><p>$\beta$是参数向量$\begin{matrix}[\beta_0,\beta_1…]\end{matrix}$。</p><p>…………………………………………………</p><h6 id="2-2-OLSE-Ordinary-Least-Square-Estimate-的性质"><a href="#2-2-OLSE-Ordinary-Least-Square-Estimate-的性质" class="headerlink" title="2.2 OLSE(Ordinary Least Square Estimate)的性质"></a>2.2 OLSE(Ordinary Least Square Estimate)的性质</h6><ul><li>最小二乘估计量$\beta_1$与$\beta_0$各自的方差及协方差</li></ul><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200615211903753.png" alt="image-20200615211903753"></p><ul><li><p>对于第二个$Var(\hat{\beta_0})$的证明：</p><ul><li><p>此前已知：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200615212203191.png" alt="image-20200615212203191"></p></li><li><p>所以：</p><p>$Var\hat{\beta_0}=Var{\sum[\frac{1}{n}-\bar{x}\frac{(x_i-\bar{x})}{ L_{xx} }]y_i}=\sum[\frac{1}{n}-\bar{x}\frac{(x_i-\bar{x})}{ L_{xx} }]^2Var(y_i)=\sum[\frac{1}{n^2}-2*\frac{1}{n}*hhh+hhh^2]\sigma_u^2$，令$hhh=\bar{x}\frac{(x_i-\bar{x})}{ L_{xx} }$.</p><ul><li>其中系数等于：$\sum\frac{1}{n^2}-\frac{2\bar{x}}{n}\frac{\sum(x_i-\bar{x})}{L_{xx}}+\bar{x}^2\frac{\cancel{L_{xx}}}{[L_{xx}]^\cancel{2}}$，中间那一项为0</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E6%95%B0%E6%8D%AE%E9%A2%84%E8%A7%88%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    <url>/2020/10/11/%E6%95%B0%E6%8D%AE%E9%A2%84%E8%A7%88%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>目录：</p><p><img src="https://img-blog.csdnimg.cn/20190829115257748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZmFuZ2NoZW55dW5mZW5n,size_16,color_FFFFFF,t_70"></p><p>(学了新东西再更)</p><a id="more"></a><p><strong>train.csv = X |y</strong> </p><p>​        <strong>=  X_train |y_trian</strong></p><p>​           <strong>X_test  |y_test</strong></p><p><a href="http://chenyunfeng.com/wp-content/uploads/2019/06/Train.csv">Train.csv</a> （浏览器打开下载）</p><p><img src="https://user-images.githubusercontent.com/49241298/75753097-f5ca2580-5d64-11ea-95da-40ed53b3cf40.png"></p><h4 id="1-数据预览"><a href="#1-数据预览" class="headerlink" title="1.    数据预览"></a>1.    数据预览</h4><h5 id="1-1-DataFrame预览："><a href="#1-1-DataFrame预览：" class="headerlink" title="1.1    DataFrame预览："></a>1.1    DataFrame预览：</h5><pre><code class="hljs python">train.head() <span class="hljs-comment"># 查看前五行</span></code></pre><pre><code class="hljs python">train.describe() <span class="hljs-comment"># 查看数值型列</span></code></pre><pre><code class="hljs python">train.shape <span class="hljs-comment"># 查看行数，列数</span></code></pre><pre><code class="hljs python">train.columns <span class="hljs-comment">#取columns，可.tolist()转化</span></code></pre><pre><code class="hljs python">train.columns.values <span class="hljs-comment">#直接获取列的值</span></code></pre><pre><code class="hljs python">pd.set_option(<span class="hljs-string">&#x27;display.max_columns&#x27;</span>,<span class="hljs-number">25</span>) <span class="hljs-comment">#↑ 在notebook里，如果train的列太多，train.head()只能显示部分列。可以通过pd.set_opition()来设置任意想显示的列数。之后还可以通过pd.reset_option(&#x27;display.max_columns&#x27;)恢复默认设置</span></code></pre><h5 id="1-2-DataFrame查看特定行、列："><a href="#1-2-DataFrame查看特定行、列：" class="headerlink" title="1.2    DataFrame查看特定行、列："></a>1.2    DataFrame查看特定行、列：</h5><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>] <span class="hljs-comment">#age列，type=Series</span></code></pre><pre><code class="hljs python">train.age   <span class="hljs-comment">#和train[&#x27;age&#x27;]相同</span></code></pre><pre><code class="hljs python">train.loc[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;job&#x27;</span>] <span class="hljs-comment">#双闭，前6行，前2列</span></code></pre><pre><code class="hljs python">train.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>] <span class="hljs-comment">#左闭右开，前5行，前1列</span></code></pre><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>][<span class="hljs-number">0</span>:<span class="hljs-number">5</span>] <span class="hljs-comment">#左闭右开，age列，前5行</span></code></pre><pre><code class="hljs python">train[[<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;marital&#x27;</span>]] <span class="hljs-comment">#取两列</span></code></pre><h5 id="1-3-DataFrame查看列的级别（即“取值范围”）："><a href="#1-3-DataFrame查看列的级别（即“取值范围”）：" class="headerlink" title="1.3    DataFrame查看列的级别（即“取值范围”）："></a>1.3    DataFrame查看列的级别（即“取值范围”）：</h5><pre><code class="hljs python"><span class="hljs-comment">#方法一：</span>train[<span class="hljs-string">&#x27;age&#x27;</span>].value_counts().index <span class="hljs-comment">#获取级别，按计数降序排列</span></code></pre><pre><code class="hljs python"><span class="hljs-comment">#方法二：（不常用， 一般使用方法一。假装已经&#x27;import pandas as pd&#x27;了）</span>pd.Series(train[<span class="hljs-string">&#x27;age&#x27;</span>].values).unique() <span class="hljs-comment">#type=array,顺序为该值在train中的出现顺序，数值型可.sort()排序</span></code></pre><pre><code class="hljs python"><span class="hljs-comment">#from sklearn.utils.multiclass import unique_labels</span>unique_labels(train[<span class="hljs-string">&#x27;age&#x27;</span>]) <span class="hljs-comment">#output:array([17, 18, 19, 20, 21, 22, 23,...</span></code></pre><h5 id="1-4-DataFrame计数："><a href="#1-4-DataFrame计数：" class="headerlink" title="1.4    DataFrame计数："></a>1.4    DataFrame计数：</h5><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>].values <span class="hljs-comment">#type=array,顺序为df.index的顺序</span></code></pre><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>].value_counts() <span class="hljs-comment">#type=Series,已按number降序排列</span></code></pre><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>].value_counts().index <span class="hljs-comment">#获取级别（即“索引”）</span></code></pre><pre><code class="hljs python">train[<span class="hljs-string">&#x27;age&#x27;</span>].value_counts().values <span class="hljs-comment">#获取number</span></code></pre><p>↑，注意上面这三行代码的结果都是按照number降序排列的</p><ul><li>使用numpy的函数</li></ul><pre><code class="hljs python">np.mean(y_train==<span class="hljs-string">&#x27;no&#x27;</span>),np.mean(y_train==<span class="hljs-string">&#x27;yes&#x27;</span>) <span class="hljs-comment">#查看标签列的值分布</span></code></pre><ul><li>使用计数器Counter</li></ul><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> CounterCounter(y_train)  <span class="hljs-comment">#Counter参数可以为：series,array,list</span></code></pre><h4 id="2-数据清洗："><a href="#2-数据清洗：" class="headerlink" title="2.    数据清洗："></a>2.    数据清洗：</h4><h5 id="2-1-值缺失："><a href="#2-1-值缺失：" class="headerlink" title="2.1    值缺失："></a>2.1    值缺失：</h5><blockquote><p>数值型变量有缺失，可以使用中位数/均值填充，且中位数一般比均值更稳健；类别型变量有缺失，可以使用众数填充；若缺失程度太高，则可以舍弃此变量；</p><p>另外，还可以使用KNN类的算法来选择最近似的样本进行填充；</p><p>缺失信息有时也可以作为一种特征表达，例如人的性别：男、女、不详都有不同的含义。</p></blockquote><ul><li>查看缺失情况</li></ul><pre><code class="hljs python">train.isnull()train.isnull().sum()train.isnull().any()</code></pre><ul><li>填补</li></ul><pre><code class="hljs python"><span class="hljs-comment">#因为此例中的train里没有NaN，所以把age列值为50~99的置空，实际操作不需要第一步</span>train.replace(&#123;<span class="hljs-string">&#x27;age&#x27;</span>:range(<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)&#125;,np.NaN,inplace=<span class="hljs-literal">True</span>)train[<span class="hljs-string">&#x27;age&#x27;</span>].fillna(train[<span class="hljs-string">&#x27;age&#x27;</span>].mean(),inplace=<span class="hljs-literal">True</span>)</code></pre><ul><li>删除</li></ul><pre><code class="hljs python"><span class="hljs-comment">#因此例中train里没有NaN，所以我们先随意把一些值置空，然后再删除</span>train.replace(&#123;<span class="hljs-string">&#x27;education&#x27;</span>:<span class="hljs-string">&#x27;unknown&#x27;</span>&#125;,np.NaN,inplace=<span class="hljs-literal">True</span>)train.dropna(subset=[<span class="hljs-string">&#x27;education&#x27;</span>],inplace=<span class="hljs-literal">True</span>)</code></pre><h5 id="2-2-重复："><a href="#2-2-重复：" class="headerlink" title="2.2    重复："></a>2.2    重复：</h5><pre><code class="hljs python">train.duplicated() <span class="hljs-comment">#遍历所有行，每行返回True/False</span></code></pre><pre><code class="hljs python">train[train.duplicated()==<span class="hljs-literal">True</span>] <span class="hljs-comment">#显示重复的行</span></code></pre><pre><code class="hljs python">train=train.drop_duplicates(keep=<span class="hljs-string">&#x27;first&#x27;</span>) <span class="hljs-comment">#删除重复的行，保留一个</span></code></pre><h5 id="2-3-异常："><a href="#2-3-异常：" class="headerlink" title="2.3    异常："></a>2.3    异常：</h5><ul><li>异常值可视化</li></ul><pre><code class="hljs python"><span class="hljs-comment">#box检测异常值</span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snscolumns=train.select_dtypes(exclude=[<span class="hljs-string">&#x27;object&#x27;</span>]).columns.tolist() columns.remove(<span class="hljs-string">&#x27;y&#x27;</span>)fig,ax=plt.subplots(<span class="hljs-number">1</span>,len(columns),figsize=(<span class="hljs-number">16</span>,<span class="hljs-number">4</span>))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(columns)):    sns.boxplot(data=train[columns[i]],ax=ax[i])    ax[i].set_title(columns[i])plt.show()</code></pre><ul><li>根据boxplot删除有异常值的样本：</li></ul><pre><code class="hljs python"><span class="hljs-comment">#保留age&lt;70的样本（即删除≥70的样本）</span>train=train[train[<span class="hljs-string">&#x27;age&#x27;</span>]&lt;=<span class="hljs-number">70</span>]</code></pre><h4 id="3-区间缩放"><a href="#3-区间缩放" class="headerlink" title="3.    区间缩放"></a>3.    区间缩放</h4><h5 id="3-1-preprocessing-scale"><a href="#3-1-preprocessing-scale" class="headerlink" title="3.1    preprocessing.scale"></a>3.1    preprocessing.scale</h5><p>公式：(X-mean)/std ；可以缩放指定列，包括1维和多维；缩放之后，所有维数总均值→0，总方差→1(均值并不总是等于0)；</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing<span class="hljs-comment"># train[&#x27;cons.price.idx&#x27;]列原来的取值范围为92~95左右</span>train[<span class="hljs-string">&#x27;cons.price.idx&#x27;</span>]=preprocessing.scale(train[<span class="hljs-string">&#x27;cons.price.idx&#x27;</span>])<span class="hljs-comment"># 处理之后每个feature的分布不变(当样本很少时分布变化可能会比较大)</span></code></pre><h5 id="3-2-preprocessing-StandardScaler"><a href="#3-2-preprocessing-StandardScaler" class="headerlink" title="3.2    preprocessing.StandardScaler"></a>3.2    preprocessing.StandardScaler</h5><p>公式同上，(X-mean)/std；只能处理多维；处理之后总均值→0，总方差→1；</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScalerdata = [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">4</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]scaler = StandardScaler(copy=<span class="hljs-literal">False</span>) <span class="hljs-comment">#参数with_maen和with_std默认为True，即去中心化并将方差缩放为1</span>data=scaler.fit_transform(data) <span class="hljs-comment">#copy=False表示在原数据上缩放，但一般没有用，所以需要赋值一下</span><span class="hljs-comment"># 结果：data.mean()=9.25185853854297e-18，data.std()=1.0</span></code></pre><h4 id="4-特征编码"><a href="#4-特征编码" class="headerlink" title="4.    特征编码"></a>4.    特征编码</h4><h5 id="4-1-独热编码，增维"><a href="#4-1-独热编码，增维" class="headerlink" title="4.1    独热编码，增维"></a>4.1    独热编码，增维</h5><ul><li>方法1：pd.get_dummies</li></ul><pre><code class="hljs python"><span class="hljs-comment"># #将所有非数值型变量改为哑变量</span>train_not_value=X.select_dtypes(include=[<span class="hljs-string">&#x27;object&#x27;</span>])column_names=train_not_value.columns.tolist()<span class="hljs-comment">#转为one_hot:</span><span class="hljs-keyword">for</span> column_name <span class="hljs-keyword">in</span> column_names:    dummy_ranks = pd.get_dummies(X[column_name], prefix=column_name)    cols_to_keep = X.columns.tolist()    cols_to_keep.remove(column_name)    X = X[cols_to_keep].join(dummy_ranks.loc[:, column_name:])<span class="hljs-comment">#结果：</span><span class="hljs-comment">#marital 转化为四列： marital_divorced, marital_married,marital_single,marital_unknown</span></code></pre><ul><li>方法2：label_binarize </li></ul><pre><code class="hljs python"><span class="hljs-comment"># 方法2</span><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> label_binarizeclasses=[<span class="hljs-string">&#x27;divorced&#x27;</span>, <span class="hljs-string">&#x27;married&#x27;</span>,<span class="hljs-string">&#x27;single&#x27;</span>,<span class="hljs-string">&#x27;unknown&#x27;</span>]label_binarize(X[<span class="hljs-string">&#x27;marital&#x27;</span>], classes=classes)<span class="hljs-comment">#结果：相当于把get_dummy返回的df中的值导出为array</span><span class="hljs-comment"># [[0 0 1 0]</span><span class="hljs-comment">#  [0 1 0 0]</span><span class="hljs-comment">#  [0 0 1 0]</span><span class="hljs-comment">#  ...</span><span class="hljs-comment">#  [0 1 0 0]</span><span class="hljs-comment">#  [0 1 0 0]</span><span class="hljs-comment">#  [0 0 1 0]]</span></code></pre><h5 id="4-2-字典编码，不增维"><a href="#4-2-字典编码，不增维" class="headerlink" title="4.2    字典编码，不增维"></a>4.2    字典编码，不增维</h5><blockquote><p>在使用树形模型时，用LabelEncoder的效果一般比OneHotEncoder好？</p></blockquote><ul><li>方法1：LabelEncoder，标签编码</li></ul><pre><code class="hljs python"><span class="hljs-comment"># #将所有非数值型变量改为哑变量</span>train_not_value=X.select_dtypes(include=[<span class="hljs-string">&#x27;object&#x27;</span>])column_names=train_not_value.columns.tolist()<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing<span class="hljs-comment">#encoder</span><span class="hljs-keyword">for</span> column_name <span class="hljs-keyword">in</span> column_names:    le = preprocessing.LabelEncoder()    le.fit(X[column_name].unique())    X[column_name]=le.transform(X[column_name])<span class="hljs-comment">#结果： martial：&#x27;divorced&#x27;,&#x27;married&#x27; 转化为 martial：0,1</span><span class="hljs-comment"># X[&#x27;marital&#x27;].value_counts()：</span><span class="hljs-comment"># 1    18018</span><span class="hljs-comment"># 2     8441</span><span class="hljs-comment"># 0     3333</span><span class="hljs-comment"># 3       50</span><span class="hljs-comment"># Name: marital, dtype: int64</span></code></pre><ul><li>方法2： pd.factorize</li></ul><pre><code class="hljs python">a=pd.factorize(train[<span class="hljs-string">&#x27;job&#x27;</span>]) <span class="hljs-comment">#结果如下：</span><span class="hljs-comment"># (array([0, 1, 2, ..., 7, 3, 3], dtype=int64),</span><span class="hljs-comment">#  Index([&#x27;blue-collar&#x27;, &#x27;technician&#x27;, &#x27;services&#x27;, &#x27;admin.&#x27;, &#x27;housemaid&#x27;,</span><span class="hljs-comment">#         &#x27;management&#x27;, &#x27;retired&#x27;, &#x27;self-employed&#x27;, &#x27;entrepreneur&#x27;, &#x27;student&#x27;,</span><span class="hljs-comment">#         &#x27;unemployed&#x27;, &#x27;unknown&#x27;],</span><span class="hljs-comment">#        dtype=&#x27;object&#x27;))</span></code></pre><h5 id="4-3-序列编码"><a href="#4-3-序列编码" class="headerlink" title="4.3    序列编码"></a>4.3    序列编码</h5><blockquote><p>有时需要转码之后的数字包含权重信息，如温度的高、中和低。这是一般使用字典序列来编码，这样就保留了高＞中＞低的信息；</p></blockquote><pre><code class="hljs python"><span class="hljs-comment"># 假设我们有一个DataFrame，其中有一个特征‘温度’，取值为‘high’，‘medium’，‘low’</span>map_dict=&#123;<span class="hljs-string">&#x27;low&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;mediun&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;high&#x27;</span>:<span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map_values</span>(<span class="hljs-params">x</span>):</span>    <span class="hljs-keyword">return</span> map_dict[x]DataFrame[<span class="hljs-string">&#x27;temperature&#x27;</span>]=DataFrame[<span class="hljs-string">&#x27;temperature&#x27;</span>].apply(lambla x:map_values(x))</code></pre><p>除此之外，HashingEncoder、BinaryEncoder还没用过……</p><h4 id="5-平衡数据"><a href="#5-平衡数据" class="headerlink" title="5.    平衡数据"></a>5.    平衡数据</h4><h5 id="5-1-上采样-增加少数类样本量-SMOTE："><a href="#5-1-上采样-增加少数类样本量-SMOTE：" class="headerlink" title="5.1    上采样(增加少数类样本量)SMOTE："></a>5.1    上采样(增加少数类样本量)SMOTE：</h5><pre><code class="hljs python"><span class="hljs-comment"># smote平衡</span><span class="hljs-keyword">from</span> imblearn.over_sampling <span class="hljs-keyword">import</span> SMOTEsmo = SMOTE(random_state=<span class="hljs-number">42</span>)X_smo, y_smo = smo.fit_sample(X_train, y_train)<span class="hljs-comment">#除了1:1，还可以选择其他比例：</span>smo = SMOTE(ratio=&#123;<span class="hljs-number">1</span>: <span class="hljs-number">300</span> &#125;,random_state=<span class="hljs-number">42</span>) <span class="hljs-comment">#使1的数量为300</span></code></pre><h4 id="6-EDA-Exploratory-data-analysis，探索性数据分析"><a href="#6-EDA-Exploratory-data-analysis，探索性数据分析" class="headerlink" title="6.    EDA(Exploratory data analysis，探索性数据分析)"></a>6.    EDA(Exploratory data analysis，探索性数据分析)</h4><pre><code class="hljs python"><span class="hljs-comment">#在以下可视化之前，将no/yes 转 0/1，方便统计</span>train.loc[train[<span class="hljs-string">&#x27;y&#x27;</span>]==<span class="hljs-string">&#x27;no&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>]=<span class="hljs-number">0</span>train.loc[train[<span class="hljs-string">&#x27;y&#x27;</span>]==<span class="hljs-string">&#x27;yes&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>]=<span class="hljs-number">1</span></code></pre><h5 id="6-1-查看不同类别（买-不买）下所有features的分布"><a href="#6-1-查看不同类别（买-不买）下所有features的分布" class="headerlink" title="6.1    查看不同类别（买/不买）下所有features的分布"></a>6.1    查看不同类别（买/不买）下所有features的分布</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<span class="hljs-comment">#import matplotlib.pyplot as plt</span>columns=train.select_dtypes(exclude=[<span class="hljs-string">&#x27;object&#x27;</span>]).columns.tolist() columns.remove(<span class="hljs-string">&#x27;y&#x27;</span>)<span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> columns:    _min=train[column].min()    _max=train[column].max()    facet = sns.FacetGrid(train,hue=<span class="hljs-string">&quot;y&quot;</span>,aspect=<span class="hljs-number">4</span>)    facet.map(sns.kdeplot,column,shade=<span class="hljs-literal">True</span>)    facet.set(xlim=(<span class="hljs-number">0</span>,_max))    facet.add_legend() plt.show()</code></pre><ul><li>输出（只截取一部分）：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190829111759518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZmFuZ2NoZW55dW5mZW5n,size_16,color_FFFFFF,t_70"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="6-2-查看不同job、不同类别-买-不买-的情况下age的分布-小提琴图"><a href="#6-2-查看不同job、不同类别-买-不买-的情况下age的分布-小提琴图" class="headerlink" title="6.2    查看不同job、不同类别(买/不买)的情况下age的分布(小提琴图)"></a>6.2    查看不同job、不同类别(买/不买)的情况下age的分布(小提琴图)</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsplt.figure(figsize = (<span class="hljs-number">15</span>,<span class="hljs-number">4</span>))<span class="hljs-comment">#设置y轴值域</span>age_min=train[<span class="hljs-string">&#x27;age&#x27;</span>].min()age_max=train[<span class="hljs-string">&#x27;age&#x27;</span>].max()plt.yticks(range(age_min,age_max,<span class="hljs-number">10</span>))sns.violinplot(<span class="hljs-string">&quot;job&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,hue=<span class="hljs-string">&quot;y&quot;</span>,data=train,split=<span class="hljs-literal">True</span>)plt.title(<span class="hljs-string">&#x27;job+age vs y&#x27;</span>) plt.show()</code></pre><ul><li>输出：</li></ul><p><img src="https://img-blog.csdnimg.cn/20190829112358930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vZmFuZ2NoZW55dW5mZW5n,size_16,color_FFFFFF,t_70"></p><h5 id="6-3-相关系数矩阵"><a href="#6-3-相关系数矩阵" class="headerlink" title="6.3    相关系数矩阵"></a>6.3    相关系数矩阵</h5><pre><code class="hljs python"><span class="hljs-comment"># 仅显示类型为数值型的特征之间的关系;</span><span class="hljs-comment"># 因为相关系数矩阵是对称矩阵，所以画图时仅取其对应的下三角矩阵；</span>mask = np.zeros_like(train.corr()) mask[np.triu_indices_from(mask)] = <span class="hljs-literal">True</span>sns.heatmap(train.corr(),annot=<span class="hljs-literal">False</span>,mask=mask,cmap=<span class="hljs-string">&#x27;YlGnBu&#x27;</span>)<span class="hljs-comment"># 常用的cmap:https://matplotlib.org/examples/color/colormaps_reference.html</span><span class="hljs-comment"># 结果如图：</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20190719110839257.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E6%9E%81%E9%99%90/"/>
    <url>/2020/10/11/%E6%9E%81%E9%99%90/</url>
    
    <content type="html"><![CDATA[<h4 id="二、数列极限"><a href="#二、数列极限" class="headerlink" title="二、数列极限"></a>二、数列极限</h4><h5 id="0-引言"><a href="#0-引言" class="headerlink" title="0.引言"></a>0.引言</h5><ul><li><p>极限是一个“无限趋近的过程”</p></li><li><p>【例1.2.1】[大纲有，但未考过]用定义证明$\lim_{n→\infty}[1+\frac{(-1)^n}{n}]=1$.</p><p>①写$|1+\frac{(-1)^n}{n}-1|&lt;\epsilon$</p><p>②$\frac{1}{n}&lt;\epsilon\Longrightarrow n&gt;\frac{1}{\epsilon}$</p><p>③取$N=[\frac{1}{\epsilon}]+1$</p><p>所以，$\forall n&gt;0$，当$n&gt;N$时，有$n&gt;[\frac{1}{\epsilon}]+1$，使得$|1+\frac{(-1)^n}{n}-1|&lt;\epsilon$</p></li></ul><a id="more"></a><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h5><ul><li><p>设${x_n}$是一个无穷数列，<strong>若存在常数a</strong>，对于$\forall \epsilon&gt;0$，$\exists N&gt;0$，当$n&gt;N$时，$|x_n-a|&lt;\epsilon$，则称数列${x_n}$收敛于$a$，或称其极限为$a$，记为$\lim_{n→\infty}x_n=a$。若不存在这样的$a$，则数列是发散的。<font color='red'>【专指$+\infty$】</font>.</p></li><li><p>常用语言：$lim_{n→\infty}=a\Leftarrow=\Rightarrow\forall \epsilon&gt;0,\exists N&gt;0,当n&gt;N时,|x_n-a|&lt;\epsilon恒成立$.</p><p>【例1.2.2】已知$lim_{n→\infty}x_n=a,求证lin_{n→\infty}|x_n|=|a|$.</p><p>【660-144】”$f(x)$在$x_0$处连续“是”$|f(x)|$在$x_0$处连续“的___条件。</p><blockquote><p>常用不等式：$|a±b|≤|a|±|b|$，$||a|-|b||≤|a-b|$，</p></blockquote></li><li><p>数列收敛于子列收敛的关系</p><ul><li><p>若数列${a_n}$收敛，则其所有子数列${a_{nk}}$均收敛，且收敛于同一极限。</p><p><font color='deepskyblue'>【660-121】</font>是否正确？：数列$lim_{n→\infty}{x_n}=a\Leftarrow\Rightarrow lim_{n→\infty}{x_{2n}}=lim_{n→\infty}{x_{2n+1}}=a$.</p></li><li><p>↑若至少一个子列发散，则原数列发散；若存在两个子列收敛于不同的值，则原数列发散。</p></li></ul></li></ul><h5 id="2-性质"><a href="#2-性质" class="headerlink" title="2. 性质"></a>2. 性质</h5><ul><li>唯一性</li><li>有界性</li><li><font color='red'><strong>保号性</strong></font>【改到函数的保号性那里！！！！！】<ul><li>脱帽性：$lim_{n→\infty}a_n=a&gt;0\Longrightarrow a_n&gt;0$，<font color='red'>$(n&gt;N)$</font></li><li>戴帽性：如果从第$n$项开始，$a_n&gt;0$，且$lim_{n→\infty}a_n=a$，则<font color='red'>$a≥0$</font>.<font color='red'>带帽结果<strong>一定要加等号</strong></font>$^{【费马定理】}$，如$a_n&gt;0,但lima_n=0$.</li></ul></li></ul><h5 id="3-极限运算法则"><a href="#3-极限运算法则" class="headerlink" title="3. 极限运算法则"></a>3. 极限运算法则</h5><ul><li><p>+-*/的极限等于极限的+-*/</p><p>【例1.2.4】已知$lim_{n→\infty}(a_n+b_n)=2,lim_{n→\infty}(a_n-b_n)=1$，证明数列${a_n}和{b_n}$极限均存在，并求出具体值</p></li></ul><h5 id="4-夹逼准则"><a href="#4-夹逼准则" class="headerlink" title="4. 夹逼准则"></a>4. 夹逼准则</h5><ul><li><p>对于数列$x_n,y_n,z_n$，如果有$x_n&lt;y_n&lt;z_n$，且$lim_{n→\infty}x_n=lim_{n→\infty}z_n=A,lim_{n→\infty}y_n$存在，则$lim_{n→\infty}y_n=A$.</p></li><li><p>$x_n,y_n,z_n$不验证等号</p><p>【例1.2.5】求极限$lim_{n→\infty}(\frac{n}{n^2+1}+\frac{n}{n^2+2}+…+\frac{n}{n^2+n})$.</p><p>【习1.2.2】求极限$lim_{n→\infty}(\frac{1}{\sqrt{n^2+1}}+\frac{1}{\sqrt{n^2+2}}+…+\frac{1}{\sqrt{n^2+n}})$.</p><p>【习1.2.3】求极限$lim_{n→\infty}(\frac{1}{n^2+n+1}+\frac{1}{n^2+n+2}+…+\frac{1}{n^2+n+n})$.</p><p>[<strong>放缩只动分母，不动分子</strong>]</p></li></ul><h5 id="5-单调有界准则（压轴题考点）"><a href="#5-单调有界准则（压轴题考点）" class="headerlink" title="5. 单调有界准则（压轴题考点）"></a>5. <font color='red'>单调有界准则（压轴题考点）</font></h5><ul><li>单调有界数列必有极限：数列${x_n}$<font color='red'><u>单调</u></font>增（或单调减），且<font color='red'><u>有上界</u></font>（或有下界），则$lim_{n→\infty}x_n$存在.</li><li><font color='red'>见到<strong>递推公式$a_{n+1}=f(a_n)$</strong>$\Longrightarrow$一般用单调有界准则</font>.</li><li><font color='deepskyblue'>【660-121】</font>数列极限$lim_{n→\infty}x_n\exist\Leftarrow\Rightarrow lim_{n→\infty}{\frac{x_{n+1}}{x_n}}=1$是否正确？.</li><li><font color='deepskyblue'>【例1.2.4】</font>设数列$$..</li></ul><h4 id="三、函数极限"><a href="#三、函数极限" class="headerlink" title="三、函数极限"></a>三、函数极限</h4><h5 id="1-邻域"><a href="#1-邻域" class="headerlink" title="1. 邻域"></a>1. 邻域</h5><ul><li>【<del>点$x_0$周围的一片区域，成为邻域，计作$U(x_0)$</del>】以点$x_0$为中心的任何开区间成为$x_0$的邻域，记为$U(x_0)$.</li><li>$\delta$邻域：设$\delta&gt;0$，则开区间$(x-\delta,x+\delta)$为$x_0$的邻域，计作$U(x_0,\delta)$</li><li>左邻域，右邻域</li></ul><h5 id="2-极限定义"><a href="#2-极限定义" class="headerlink" title="2. 极限定义"></a>2. 极限定义</h5><ul><li>对于函数$f(x)$，对于$\forall \epsilon&gt;0$，存在$\xi&gt;0$，当$0&lt;|x-x_0|&lt;\xi$时，使得$|f(x)-A|&lt;\epsilon$，则称函数$f(x)$在$x$趋近于$x_0$收敛于A，或称$f(x)$在$x$趋于$x_0$时的极限为A.</li><li>对于函数$f(x)$，对于任意的$\epsilon&gt;0$，存在正整数$X&gt;0$，当$\color{Red}|x|&gt;X$时，有$|f(x)-A|&lt;\epsilon$，则记为$lim_{x→\infty}f(x)=A$</li><li>$lim_{x→x_0}f(x)=A\Leftarrow\Rightarrow lim_{x→x_0^+}f(x)=lim_{x→x_0^-}f(x)=A$.【多元极限此方法有稳定性和可靠性】</li><li>$lim_{x→x_0}f(x)=A\Leftarrow\Rightarrow f(x)=A+\alpha(x)$，其中$lim_{x→x_0}\alpha(x)=0$.</li></ul><h5 id="3-性质"><a href="#3-性质" class="headerlink" title="3. 性质"></a>3. 性质</h5><ul><li><p>唯一性：$lim_{x→x_0}f(x)=A\Leftarrow=\Rightarrow lim_{x→x_0^-}f(x)=lim_{x→x_0^+}f(x)=A$.</p></li><li><p>局部有界性：若$lim_{x→x_0}f(x)=A\Longrightarrow \exists M&gt;0,\delta&gt;0$，当$0&lt;|x-x_0|&lt;\delta$时，$|f(x)|≤M$.【$lim_{x→\infty}f(x)=A\Longrightarrow\exist M&gt;0,\exist X&gt;0,当|x|&gt;X时,|f(x)|≤M$】</p><ul><li><p>判断局部有界的四种方法：</p><ul><li>$limf(x)=A\Rightarrow|f(x)|≤M$.</li><li>设$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上有界.</li><li><strong>有限个有界函数的和、差、积仍为有界函数</strong>.</li><li>若$f’(x)$在$(a,b)$内有界，则$f(x)$在$(a,b)$内有界.</li></ul></li><li><p><strong>无穷大与无界的关系</strong>：</p><ul><li><p>$lim_{x→x_0}f(x)=\infty\cancel{\Leftarrow}\Rightarrow f(x)$在$x_0$的任意去心邻域内无界.</p></li><li><p>$\exist x_n,lim_{n→\infty}x_n=x_0$，使得$lim_{n→\infty}f(x_n)=\infty\Leftarrow\Rightarrow f(x)$在$x_0$的任意去心邻域内无界.</p><blockquote><p>证明：<font color='red'>【$lim_{n→\infty}x_n=x_0$等价于$x→x_0$】</font>.</p><p>充分性：左边→$\forall M&gt;0,\delta&gt;0$，<font color='blue'>$\exist N&gt;0，当n&gt;N时，0&lt;|x_n-x_0|&lt;\delta$</font>，$|f(x_n)|&gt;M$.</p><p>必要性：右边→$f(x)在\forall U(x_0,\frac{1}{n}),(n=1,2,…)内无界$→$\forall M=n&gt;0,\exist x_n\in(x_0,\frac{1}{n}),|f(x_n)|&gt;M$→左边</p></blockquote></li><li><p><font color='deepskyblue'>【660-145】</font>$f(x)在[a,+\infty)连续$，则”$\exist n\in[a,+\infty),使得lim_{n→\infty}x_n=+\infty,且lim_{n→\infty}f(x_n)=+\infty$“是$f(x)在[a,+\infty)上无界$的___条件。</p><blockquote><p>$f(x)$在某区间内无界$\Leftarrow\Rightarrow\forall M,f(x)$在此区间内无界</p></blockquote></li><li><p><font color='deepskyblue'>【660-124】</font>下列正确的是：</p><p>（A）如果$f(x)$在$x_0$的任意去心邻域内无界，则$lim_{x→x_0}f(x)=\infty$.</p><p>（B）如果$lim_{x→x_0}f(x)=\infty$，则$f(x)$在$x_0$的任意去心邻域内无界.</p><p>（C）如果$lim_{x→x_0}f(x)=0$，则$lim_{x→x_0}\frac{1}{f(x)}=\infty$.</p><blockquote><p>对于D，若$lim_{x→x_0}f(x)=0$，且$f(x)\not=0$，则$lim_{x→x_0}\frac{1}{f(x)}=\infty$.若$f(x)$在0处无定义，则不行。</p><p>对于A，举例，设$f(x)=\frac{1}{x}sin\frac{1}{x}$，令$x_n=\frac{1}{2n\pi+\frac{\pi}{2}},y_n=\frac{1}{n\pi}$，则$n→\infty时，x_n→0,y_n→0$，但$lim_{n→\infty}f(x_n)=lim_{n→\infty}2n\pi+\frac{\pi}{2}=\infty$，$lim_{n→\infty}f(y_n)=0$，极限不是无穷大，而是不存在（在0和无穷大反复震荡）</p></blockquote></li></ul></li></ul></li><li><p>局部保号性</p><ul><li>脱帽性：$lim_{x→x_0}f(x)=A&gt;0$，则当$x→x_0$时，$f(x)&gt;0$.$^{\color{BurntOrange}{导数零点定理的证明}}$.【注意是$x_0$的去心邻域内$f(x)&gt;0$，与$x_0$点处的函数值无关系】<ul><li><font color='deepskyblue'>【660-125】</font>若$lim_{x→x_0}f(x)≥lim_{x→x_0}g(x)$，则$\exist \delta&gt;0,当0&lt;|x-x_0|&lt;\delta$时，有$f(x)≥g(x)$.</li></ul></li><li>戴帽性：在$x_0$的邻域内，$f(x)&gt;0$且极限存在，则$lim_{x→x_0}f(x)≥0$.$\color{Red}^{费马定理的证明}$.</li></ul></li></ul><h5 id="4-运算法则"><a href="#4-运算法则" class="headerlink" title="4. 运算法则"></a>4. 运算法则</h5><ul><li><p>+-×/的极限等于极限的+-×/</p></li><li><p>$limf(x)=A,limg(x)=B\Rightarrow lim\frac{f(x)}{g(x)}=\frac{A}{B}$，$limf(x)g(x)=A*B$.</p></li><li><p><strong>常用结论</strong>：</p><p>对于<strong>七个</strong>趋向过程，</p><ul><li>若$limf(x)=A,limg(x)\cancel{\exist}$，则$lim[f(x)+g(x)]\ \cancel{\exist}$.<ul><li>若$A\not=0$，则$limf(x)g(x)\cancel{\exist}$.</li><li>若$A=0$，则$limf(x)g(x)$可能存在，也可能不存在</li></ul></li><li>若$limf(x),limg(x)均\cancel{\exist}$，则$lim[f(x)+g(x)]$和$limf(x)g(x)$都不存在</li></ul></li></ul><h5 id="5-夹逼准则"><a href="#5-夹逼准则" class="headerlink" title="5. 夹逼准则"></a>5. 夹逼准则</h5><ul><li>对于函数$f(x),g(x),h(x)$如果有$f(x)&lt;g(x)&lt;h(x)$，且$lim_{x→\infty}f(x)=lim_{x→\infty}h(x)=A$，$g(x)$极限存在，则有$lim_{x→\infty}g(x)=A$.</li></ul><h5 id="6-洛必达法则"><a href="#6-洛必达法则" class="headerlink" title="6. 洛必达法则"></a>6. 洛必达法则</h5><ul><li><p>若①<font color='red'>在$x→a$或者$x→\infty$时，函数$f(x)$及$F(x)$趋近于$0$或$\infty$</font>.②函数$f(x),g(x)$均可导，$limg’(x)≠0$；②$lim\frac{f’(x)}{g’(x)}存在或无穷大$，则$lim\frac{f(x)}{g(x)}=lim\frac{f^{‘}(x)}{g^{‘’}(x)}$，$x→a或\infty$.</p><blockquote><p>①<font color='red'>一定要$\frac{0}{0}\ or\ \frac{\infty}{\infty}$，不能是非零常数</font>，如$lim_{x→0}\frac{2x-1}{x^2-x+1}$是$-1$，而非$-2$【不能用洛必达】</p><p>②不存在的情况：$lim_{x→\infty}\frac{cosx}{x}\not=lim_{x→\infty}\frac{-sinx}{1}震荡不存在$，所以不能用洛必达，而应该是：$\frac{有界}{\infty}=0$。</p></blockquote></li></ul><h5 id="7-泰勒公式"><a href="#7-泰勒公式" class="headerlink" title="7. 泰勒公式"></a>7. 泰勒公式</h5><ul><li><p>任何连续函数都可以写成基本初等函数的复合？</p></li><li><p>当$\color{Red}x→0$时，常用的8个公式$^{\color{red}{【带佩亚诺余项的n阶泰勒公式】}}$<br>$sinx=x-\frac{1}{3!}x^3+o(x^3)$.          $cosx=1-\frac{1}{2!}x^2+\frac{1}{4!}x^4+o(x^4)$.</p><p>$tanx=x+\frac{1}{3}x^3+o(x^3)$.                      $arcsinx=x+\frac{1}{3!}x^3+o(x^3)$.</p><p>$arctanx=x-\frac{1}{3}x^3+o(x^3)$.</p><p>$e^x=1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3+o(x^3)$.         $ln(1+x)=x-\frac{1}{2}x^2+\frac{1}{3}x^3+o(x^3)$.</p><p>$(1+x)^\alpha=1+\frac{\alpha}{1!}x+\frac{\alpha(\alpha-1)}{2!}x^2+\frac{\alpha(\alpha-1)(\alpha-2)}{3!}x^3+o(x^3)$.     </p></li><li><p>无穷小运算</p><ul><li>$o(x^m)±o(x^n)=o(x^l),l=min{m,n},m\not=n$.<ul><li>当同阶，即$m=n$时，$o(x^m)±o(x^n)$的阶数不变或增加</li></ul></li><li>$o(x^m)*o(x^n)=o(x^{m+n})$.</li><li><font color='#FF4500'>${o(x^m)=o(kx^m)=k*o(x^m),k≠0且为常数}$</font>.</li></ul></li><li><p><strong>泰勒展开到多少阶</strong></p></li><li><p>$\frac{A}{B}$型：展开到上下同阶</p><ul><li>$A-B$型：幂次最低</li></ul></li></ul><h6 id="7-n-等价无穷小替换"><a href="#7-n-等价无穷小替换" class="headerlink" title="7.n 等价无穷小替换"></a>7.n 等价无穷小替换</h6><ul><li><p>如图：</p><p><img src="https://pic4.zhimg.com/v2-0b9b50889edb01fc3f5467a071a323fa_1200x500.jpg" alt="高数常见坑点：等价无穷小" style="zoom:50%;" />.</p></li><li><p>对于$\sqrt[n]{1+f(x)}-1→\frac{f(x)}{n}$，等价于$[1+f(x)]^\beta→1+\beta f(x)$.【注意趋于0！！！】</p></li></ul><h5 id="8-归结原则"><a href="#8-归结原则" class="headerlink" title="8. 归结原则"></a>8. 归结原则</h5><h5 id="9-无穷小比阶"><a href="#9-无穷小比阶" class="headerlink" title="9. 无穷小比阶"></a>9. 无穷小比阶</h5><ul><li><p>当$x→0$时</p><ul><li>若$lim\frac{f(x)}{g(x)}=0$，则$f(x)$是$g(x)$的高阶无穷小</li><li>若$lim\frac{f(x)}{g(x)}=c$，则$f(x)$是$g(x)$的同阶无穷小</li><li>若$lim\frac{f(x)}{[g(x)]^k}=c$，则$f(x)$是$g(x)$的$k$阶无穷小</li><li>若$lim\frac{f(x)}{g(x)}=1$，则$f(x)$和$g(x)$是<strong>等价</strong>无穷小</li></ul></li></ul><ul><li>0是特殊的无穷小，也是<strong>最高阶</strong>的无穷小</li><li>例题<ul><li>【例1.3.17】$lim_{x→0}\frac{e^x-(ax^2+bx+1)}{x^2}=0$，则$a=?,b=?$.</li><li>【例1.3.19】排顺序：$\alpha_1=x(cos\sqrt{x}-1),\alpha_2=\sqrt x*ln(1+\sqrt{x^3}),\alpha_3=^3\sqrt{x+1}-1$.</li></ul></li></ul><h5 id="10-七种未定式的计算"><a href="#10-七种未定式的计算" class="headerlink" title="10. 七种未定式的计算"></a>10. 七种未定式的计算</h5><ul><li><p><font color='red'>第一步：化简</font></p><ol><li><p>提出极限不为0的因式，</p></li><li><p>等价无穷小替换</p><blockquote><p>拆分进行等价替换的前提条件是，拆分之后的极限都存在。如：</p><p>$lim_{x→0}\frac{e^{tanx}-e^x}{x^3}$不应该直接替换为$lim_{x→0}\frac{(tanx-1)-(x-1)}{x^3}$，而是应该拆分为$lim_{x→0}\frac{e^x(e^{tanx-x}-1)}{x^3}$，然后再进行替换.</p></blockquote></li><li><p>恒等变形</p></li></ol></li><li><p>第二步：判断类型</p><ul><li><p>$\frac{0}{0},\frac{\infty}{\infty}$：</p></li><li><p>$0*\infty$：<strong>设置分母有原则，简单因式才下放：</strong></p><p>$\begin{cases}简单:x^\alpha,\alpha^x\复杂:lnx,arcsinx\end{cases}$</p></li><li><p>$\infty-\infty$：<strong>提取+通分</strong>【提取非零因式。有分母通分，没有分母创造分母(如<strong>倒代换</strong>)也要通分】</p><p><font color='deepskyblue'>【660-17】</font>设$a,b$是常数，且$lim_{n→\infty}(\sqrt[3]{1-x^6}-ax^2-b)=0$，则$a=__,b=__$.</p><p><font color='deepskyblue'>【660-126】</font>$lim_{n\rightarrow\infty}sin^2(\pi\sqrt{n^2+n})$.【公式$sin(\alpha+n\pi)=(-1)^2sin(\alpha)$】</p></li><li><p>$\infty^0,0^0,1^\infty$：</p><ul><li>$\begin{cases}\infty^0→e^{\infty0}\0^0→e^{0\infty}\1^\infty→e^{\infty0}\end{cases}$.</li></ul></li></ul></li><li><p>例题</p><ul><li>【例1.3.3】求$lim_{x→0}\frac{e^{-\frac{1}{x^2}}*2x^{-3}}{100x^{99}}$.【分母下放】</li><li>【例1.3.6】求$lim_{x→\infty}x(\sqrt {x^2+100}+x)$.【负代换】</li><li>【例1.3.7】求$lim_{x→1^-}lnxln(1-x)$.【无穷小替换，因式下放】</li><li>【例1.3.10】求$lim_{x→0}(\frac{1}{sin^2x}-\frac{cos^2x}{x^2})$.【通分】</li><li>【例1.3.11】求$lim_{x→+\infty}[x^2(e^{\frac{1}{x}}-1)-x]$.【倒代换】</li><li>【例1.3.12】求$lim_{x→+\infty}(x+\sqrt{1+x^2})^\frac{1}{x}$.【基本公式$ln’(x+\sqrt{1+x^2})=\frac{1}{\sqrt{1+x^2}}$】【$e^{vlnu}$】</li><li><font color='deepskyblue'>【660-8】</font>$I=lim_{n→\infty}(e^{x^2}+x^3)^{\frac{1}{x^2}}$.【提取】</li></ul></li><li><p>泰勒方法</p><ul><li>【例1.3.8】求$lim_{x→0}\frac{arcsinx-arctanx}{sinx-tanx}$.</li></ul></li><li><p>已知极限反求参数</p><ul><li>$lim_{x→0}\frac{ln(1+x)-(ax+bx^2)}{x^2}=2$，求常数a和b【同阶，或$*x$再拆分】</li></ul></li></ul><h6 id="10-n-已知某一极限，求另一极限"><a href="#10-n-已知某一极限，求另一极限" class="headerlink" title="10.n 已知某一极限，求另一极限"></a><strong>10.n 已知某一极限，求另一极限</strong></h6><p>  如果其他普通办法求不出来，就用脱帽法。</p><ul><li>如果$lim_{x→0}\frac{x-sinx+f(x)}{x^4}$存在，则$lim_{x→0}\frac{x^3}{f(x)}=$<strong><strong>____</strong></strong>.<font color='#FF4500'>【脱帽法($A+\alpha(x)$)，或同阶，或$lim()<em>x=limA</em>x=0$然后拆分】</font>.</li><li><font color='deepskyblue'>【660-135】</font>设$lim_{x→0}\frac{sin6x-(sinx)f(x)}{x^3}=0$，求$lim_{x→0}\frac{6-f(x)}{x^2}$.</li></ul><h5 id="11-连续点与间断点"><a href="#11-连续点与间断点" class="headerlink" title="11. 连续点与间断点"></a>11. 连续点与间断点</h5><ul><li><p>连续点定义</p><ul><li><strong>$f(x)$在$U(x_0,\delta)$内有定义</strong>，且$lim_{x→x_0}f(x)=f(x_0)$，则称函数$f(x)$在$x_{0}$处连续。【“邻域内有定义”这个条件是给极限的】【$x_0$两侧都要有定义】【是对<strong>过程</strong>的研究，<strong>与$x_0$处无关</strong>】</li></ul></li><li><p>间断点的定义与分类<font color='red'>【间断点也一定要满足$U(x_0,\delta)$内有定义吗】【联系：与铅锤渐近线的区别】</font>.</p><ul><li>若$lim_{x→x_0^-}f(x),lim_{x→x_0^+}f(x),f(x_0)$三者中有任意二者不相等，则函数$f(x)$在点$x_{0}$出间断.</li><li>第一类间断点<ul><li>可去间断点：$lim_{x→x_0}f(x)=A≠f(x_0)$，<strong>或$f(x_0)$直接不存在，$x_0$无定义</strong>.</li><li>跳跃间断点：$lim_{x→x_0^-}f(x)≠lim_{x→x_0^+f(x)}$.</li></ul></li><li>第二类间断点<ul><li>无穷间断点：$lim_{x→x_0}f(x)=\infty$.【两侧均为无穷大？至少一个无穷大？】</li><li>振荡间断点：$lim_{x→x_0}$振荡不存在</li></ul></li></ul></li><li><p>例题</p><ul><li><p>【例1.3.20】$f(x)=\begin{cases}2x+a,x≤0\e^x(sinx+cosx),x&gt;0\end{cases}$在$(0,+\infty)$上连续，则a=__<em>__\</em>.</p><blockquote><p><font color='red'><strong>讨论间断，只看两类点</strong></font>：</p><p><font color='red'><strong>①分段函数的分段点</strong></font>.</p><p><font color='red'><strong>②无定义点</strong></font>.</p></blockquote></li><li><p>【例1.3.22】$f(x)=\frac{ln|x|}{|x-1|}sinx$，则$f(x)$的间断点情况为:____.</p></li><li><p>【习】求$f(x)=ln(1+x)+\frac{x-x^3}{tan\pi x}$的间断点.</p></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E9%AB%98%E6%95%B0%E9%94%99%E9%A2%98%E6%9C%AC/"/>
    <url>/2020/10/11/%E9%AB%98%E6%95%B0%E9%94%99%E9%A2%98%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h4 id="一元积分"><a href="#一元积分" class="headerlink" title="一元积分"></a>一元积分</h4><h5 id="1-有理函数的积分-frac-P-n-x-Q-m-x"><a href="#1-有理函数的积分-frac-P-n-x-Q-m-x" class="headerlink" title="1. 有理函数的积分$\frac{P_n(x)}{Q_m(x)}$."></a>1. 有理函数的积分$\frac{P_n(x)}{Q_m(x)}$.</h5><h6 id="解题技巧总结："><a href="#解题技巧总结：" class="headerlink" title="解题技巧总结："></a>解题技巧总结：</h6><ul><li><font color='red'>能凑微分，先凑微分</font>。能简单换元，先换元。【例1.4】</li><li>有的$\frac{P_n(x)}{Q_m(x)}$已经是最简因式了，不能拆分（/拆分后仍为自己），如$\frac{Ax+B}{(ax+b)^2},\frac{Ax+B}{ax^2+bx+c},\frac{Ax+B}{(ax^2+bx+c)^2}$【即分子次数只比分母低一次】。【例1.1】</li></ul><a id="more"></a><ul><li><del>分解之后的因式应该能够<strong>直接看出原函数</strong>，如$\frac{1}{(2x-1)^2},\frac{1}{(t+1)^2}$。否则不应该使用有理函数积分，如$\frac{1}{1-t+t^2}$。【例1.3】</del></li><li>凑分母：<ul><li>凑微分【$n&lt;m$】，如$\frac{Ax+B}{ax^2+bx+c}→\frac{\frac{A}{2a}(2ax+b)+B-\frac{Ab}{2a}}{ax^2+bx+c}$.【例1.2】</li><li>消去分母或其因式【$n&gt;m$】，【例1.7】【例1.3】</li></ul></li><li></li></ul><h6 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h6><ul><li><p>【例1.1】$\int{\frac{x+1}{(1+x^2)^2}}dx$.</p></li><li><p>【例1.2】$\int{\frac{x+5}{x^2-6x+13}}$.</p></li><li><p>【例1.3】$\int{\frac{x^4+1}{1+x^6}}dx$.</p><ul><li>不能简单换元，换不干净</li></ul></li><li><p>【例1.4】$\int{\frac{x^4+1}{x(x^2+1)^2}}dx$.</p></li><li><p>【例1.5】$\int{\frac{t+2}{t^3-1}}dx$.</p></li><li><p>【例1.6】$\int{\frac{1}{(1+2x)(1+x^2)}}dx$.</p></li><li><p>【例1.7】$\int{\frac{1}{\sqrt{x+1}-\sqrt[3]{x+1}}}dx$.</p></li></ul><h5 id="2-分部积分法"><a href="#2-分部积分法" class="headerlink" title="2. 分部积分法"></a>2. 分部积分法</h5><h6 id="解题技巧总结：-1"><a href="#解题技巧总结：-1" class="headerlink" title="解题技巧总结："></a>解题技巧总结：</h6><ul><li><font color='red'>能换元，先换元</font>。【例2.3】</li><li>与有理函数积分的结合，如$\int{\frac{P_n(x)}{Q_m(x)}}*lnx\ dx$、$\int{\frac{P_n(x)}{Q_m(x)}*e^x}\ dx$.【例2.1】<ul><li>需要注意的是，因为是和其他类型函数相乘，所以在有理拆分之后，不一定要求导到底，注意凑微分【例2.2】</li></ul></li><li></li></ul><h6 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h6><ul><li>【例2.1】$\int{\frac{x^2+1}{x(x-1)^2}}lnx\ dx$.</li><li>【例2.2】$\int{e^x(\frac{1-x}{1+x^2})^2}dx$.</li><li>【例2.3】$\int{e^{2x}arctan\sqrt{e^x-1}}dx$.</li></ul><h5 id="2-无理函数积分"><a href="#2-无理函数积分" class="headerlink" title="2. 无理函数积分"></a>2. 无理函数积分</h5><h6 id="根式类无理函数"><a href="#根式类无理函数" class="headerlink" title="根式类无理函数"></a>根式类无理函数</h6><h6 id="三角类无理函数"><a href="#三角类无理函数" class="headerlink" title="三角类无理函数"></a>三角类无理函数</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
    <url>/2020/10/11/%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h5 id="一、程序设计"><a href="#一、程序设计" class="headerlink" title="一、程序设计"></a>一、程序设计</h5><h6 id="1-Python前端"><a href="#1-Python前端" class="headerlink" title="1. Python前端"></a>1. Python前端</h6><ul><li><a href="https://doc.qt.io/qt-5/qcombobox.html">QT5_文档</a></li></ul><h5 id="2-平台转换器"><a href="#2-平台转换器" class="headerlink" title="2. 平台转换器"></a>2. 平台转换器</h5><ul><li><a href="https://www.html.cn/create-react-app/">！网站转APP</a></li><li></li></ul><h5 id="二、数据可视化"><a href="#二、数据可视化" class="headerlink" title="二、数据可视化"></a>二、数据可视化</h5><ul><li><a href="https://blockbuilder.org/jwilber/419fa6d878fe6c0f79a28f9fc72d7ec6">RoughViz-Demo</a></li><li><a href="https://github.com/microsoft/SandDance">SandDance-Github</a>、也可以使用VSCode的插件</li><li><a href="http://alexlenail.me/NN-SVG/">NN-SVG</a></li><li><a href="http://playground.tensorflow.org/">NN_Playground</a></li><li><a href="https://visualgo.net/en">算法可视化</a></li></ul><a id="more"></a><h5 id="三、人工智障"><a href="#三、人工智障" class="headerlink" title="三、人工智障"></a>三、人工智障</h5><h6 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h6><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNDgzNDg3NQ==&mid=2247486511&idx=1&sn=e1bfb83c0336e23a2255c4a095378a55&chksm=97a0c7fba0d74eedc4c7bc683c6a69fc9e09f9c8b82c7b7fc770a96a9010814473aca0a65837&mpshare=1&scene=1&srcid=1119tHe3iskDr3hQO8I5oGVj&sharer_sharetime=1574159658440&sharer_shareid=10f837e8756c33f803d5d954d500379f&key=7d1e4c0a06963a8b06b7ee0d0fce1559655244333f55cda37cedf050295cb7127cd3fcfd1bb61bb0f4586fc06b99f36d5bc133a06282a5009b4c3cb06a8359ae32e785181b9837c00ee12ceec8b2b156&ascene=1&uin=MzM3ODc1NDgzOA==&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=RiaeyN4iONbwF+M2kJoPIxk59NcZiNaS/hmy1lzFPZjhry9AfHLEwNU6LsuUjKYq">图像处理的100个必知问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/36306208">setup.py讲解</a></li><li><a href="https://www.kesci.com/home/project/5be7a385954d6e00106320d8">调参心得-Kesci</a></li><li><a href="https://zhuanlan.zhihu.com/p/31182879">XGBoost实战-知乎</a></li><li><a href="https://juejin.im/post/5d2590e1e51d45106b15ffaa">XGBoost原理-掘金</a></li><li><a href="%5Bhttps://wuhuhu800.github.io/2018/02/28/XGboost_param_share/#1%E9%80%89%E5%AE%9A%E4%B8%80%E7%BB%84%E5%9F%BA%E5%87%86%E5%8F%82%E6%95%B0%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E6%9C%89%E7%BB%8F%E9%AA%8C%E7%9A%84%E8%AF%9D%E7%94%A8%E7%BB%8F%E9%AA%8C%E5%80%BC%E6%B2%A1%E6%9C%89%E7%BB%8F%E9%AA%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%AE%98%E6%96%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%5D(https://wuhuhu800.github.io/2018/02/28/XGboost_param_share/#1%E9%80%89%E5%AE%9A%E4%B8%80%E7%BB%84%E5%9F%BA%E5%87%86%E5%8F%82%E6%95%B0%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E6%9C%89%E7%BB%8F%E9%AA%8C%E7%9A%84%E8%AF%9D%E7%94%A8%E7%BB%8F%E9%AA%8C%E5%80%BC%E6%B2%A1%E6%9C%89%E7%BB%8F%E9%AA%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%AE%98%E6%96%B9%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC)">XGBoost调参</a></li></ul><h6 id="2-Competition"><a href="#2-Competition" class="headerlink" title="2. Competition"></a>2. Competition</h6><ul><li><a href="https://tianchi.aliyun.com/competition/entrance/231759/success">Docker 练习场-天池</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDA5NDYzNA==&mid=2247483972&idx=1&sn=b8f41ae501a82780a03bd9e5dbccdc9b&chksm=96c42f81a1b3a697a7490e73297b4a4bef913af7318f9f3b5e917ff42a693003f2dd4e704613&mpshare=1&scene=1&srcid=&sharer_sharetime=1578445329442&sharer_shareid=65030b4340b230b9f1037ac3abfe34e5&key=c70ea80434848b5f309c63d44ce9659721610edcc23858d65526ddc30de838dc4be41b0da9e96d4d1749a1bc1a8eb948322ce7e9bd7058c67764a7f734d0a352cfd93971f366648ebadd9cc2bae40277&ascene=1&uin=MzM3ODc1NDgzOA==&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=A68HTEajJqEIh2lOFrUEp68=&pass_ticket=jstF4AS7U7NoO1z/CWl5d7PTzYZDyvnmRm+G+1i/Qv56ETu74fCKtRi6usLBm39i">CVPR 2020竞赛汇总</a></li><li><a href="https://mp.weixin.qq.com/s/lNndVDmc2iFzKx9Q8-i39w">竞赛方案汇总-Kaggle宝典</a></li></ul><h6 id="3-Dataset"><a href="#3-Dataset" class="headerlink" title="3. Dataset"></a>3. Dataset</h6><ul><li><a href="https://pan.baidu.com/s/1gTcB4u1k-F4g6t3EdSFCqw#list/path=%2F">CIKM</a></li></ul><h6 id="4-面试"><a href="#4-面试" class="headerlink" title="4. 面试"></a>4. 面试</h6><ul><li><a href="https://www.jiqizhixin.com/articles/2018-04-12-4">机器学习数学知识-机器之心</a></li><li><a href="https://blog.csdn.net/szlcw1/article/details/52259668">SVM常考</a></li></ul><h6 id="5-资讯"><a href="#5-资讯" class="headerlink" title="5. 资讯"></a>5. 资讯</h6><ul><li><a href="https://cloud.tencent.com/developer/article/1513775">不止于刷榜，三大CV赛事冠军算法的“研”与“用”</a></li><li><a href="https://www.jiqizhixin.com/sota">SOTA</a></li><li><a href="https://zhuanlan.zhihu.com/p/28462089?utm_source=wechat_session&utm_medium=social&utm_oi=988134170010435584">写给妹子的深度学习教学</a></li><li><a href="https://www.zhihu.com/question/26006703/answer/536169538?utm_source=wechat_session&utm_medium=social&utm_oi=988134170010435584&utm_content=pu">深度学习如何入门-知乎-量子位</a></li><li><a href="https://www.manning.com/books/deep-learning-with-python">Deep learning with Python</a></li><li><a href="http://colah.github.io/">Colah’s Blog</a></li></ul><h6 id="6-视频"><a href="#6-视频" class="headerlink" title="6. 视频"></a>6. 视频</h6><ul><li><a href="https://www.bilibili.com/video/av68141999/?p=11">FASTAI</a></li><li><a href="bilibili.com/video/av39502583/?p=16">Kaggle机器学习</a></li></ul><h6 id="7-云计算"><a href="#7-云计算" class="headerlink" title="7. 云计算"></a>7. 云计算</h6><ul><li><a href="http://104.43.220.78/user/%E6%9E%81%E5%86%B0%E7%BB%BD%E6%94%BE/tree">极冰绽放</a>，</li></ul><h5 id="四、-前端"><a href="#四、-前端" class="headerlink" title="四、 前端"></a>四、 前端</h5><h6 id="1-Plug-in"><a href="#1-Plug-in" class="headerlink" title="1. Plug-in"></a>1. Plug-in</h6><ul><li><a href="https://github.com/muhammederdem/vue-interactive-paycard">InteractivePaycard</a></li><li><a href="https://codepen.io/JavaScriptJunkie/pen/qBWrRyg?__cf_chl_jschl_tk__=02d720711d7552bd8c29947da8cf58a8eb66a8d6-1579351504-0-ARgO8bSofSGNy7mrtNLWov1_kvnaBSWk9-4Jz0JfBgzclANZXQXkEQGkrpKaULztvoY1oD9z5PLqLLredCpvtEkuVSohHuxYy-UNRJJ8k5vreojg3lGy4qrDsj4cUw1AV2GLRT0yQv6YBq4-CJG7rd6TonoVBXrSpaM-Zc9LU89e-GRTJOGNYvg5HS2qRPQ-gZdGdnbsj7_uUW2bC6cUgYzj_oDZvTnSegUOwEzkO3L1RW-2I1BbMX-6_8iwvm2oa6mCQ0xxHS7ntsreyfNYQcxbMWKRuE1Tq6jG0UBv8kzjKonUmMe7NmG3Do9dYcldOxQFBQVcB4bN2vi2SHfJlQcTFigVW-PqMEtM11L-62rX">MiniMusicPlayer</a></li><li><a href="https://mp.weixin.qq.com/s/r5oroWg18vILeyEbef_fNw">AR.js</a></li><li><a href="https://zhuanlan.zhihu.com/p/32600329">JupyterNotebook使用技巧</a></li><li><a href="https://huaji8.top/post/live2d-plugin-2.0/">Live2D</a>、<a href="https://github.com/galnetwen/Live2D">Live2D-Github</a></li></ul><h6 id="2-Repository"><a href="#2-Repository" class="headerlink" title="2. Repository"></a>2. Repository</h6><ul><li><a href="https://codepen.io/">Codepen</a></li><li><a href="https://wow.techbrood.com/fiddle/25406">TechBrooD</a></li><li><a href="http://www.html5code.net/demo/996/">Button effects</a></li><li><a href="http://www.jq22.com/daima269">JQuery</a></li></ul><h6 id="3-好玩的网站"><a href="#3-好玩的网站" class="headerlink" title="3. 好玩的网站"></a>3. 好玩的网站</h6><ul><li><a href="https://www.boxmoe.com/page/4">盒子萌</a></li><li><a href="https://www.ddosi.com/007.html">黑客数字雨</a></li><li><a href="https://www.ddosi.com/M/M.html">元素周期表</a></li><li><a href="https://sakura.2heng.xin/">Sakura</a></li><li><a href="https://christmasexperiments.com/">圣诞奇遇</a></li><li><a href="https://colorlib.com/illdy/">主题illdy的demo</a></li></ul><h6 id="4-Hexo-Next"><a href="#4-Hexo-Next" class="headerlink" title="4. Hexo-Next"></a>4. Hexo-Next</h6><ul><li>背景图<ul><li><a href="https://bufsnake.github.io/hexo-next-7-xx%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.html">hexo next 7.xx添加背景图片</a></li><li><a href="https://source.unsplash.com/">随机背景图片库</a></li></ul></li><li>主题优化<ul><li><a href="https://www.jianshu.com/p/3a01cc514ce7?utm_source=oschina-app">字数统计、阅读时长、运行时间、宠物、标签云、文章阴影、在线联系</a></li><li><a href="https://blog.csdn.net/weixin_39345384/article/details/80785373">主题优化-CSDN</a></li></ul></li><li>文档<ul><li><a href="https://theme-next.org/">NEXT主题官网</a></li><li><a href="http://theme-next.iissnan.com/">NEXT主题官网-中文</a></li></ul></li></ul><h5 id="5-爬虫"><a href="#5-爬虫" class="headerlink" title="5. 爬虫"></a>5. 爬虫</h5><h6 id="1-文档"><a href="#1-文档" class="headerlink" title="1. 文档"></a>1. 文档</h6><ul><li><a href="https://python3webspider.cuiqingcai.com/3.3-zheng-ze-biao-da-shi">网络爬虫实战-崔庆才</a></li></ul><h5 id="6-图片、视频编辑"><a href="#6-图片、视频编辑" class="headerlink" title="6. 图片、视频编辑"></a>6. 图片、视频编辑</h5><ul><li><a href="https://www.uupoop.com/">在线PS</a> </li><li><a href="https://www.iconfont.cn/">图标库</a></li><li><a href="https://colorhunt.co/">调色板</a></li><li><a href="https://tool.css-js.com/rgba.html">RGB与16进制互转</a></li><li><a href="https://www.remove.bg/">移除图片背景</a></li><li><a href="https://csacademy.com/app/graph_editor/">数据结构_图编辑器</a></li></ul><h5 id="7-笔记"><a href="#7-笔记" class="headerlink" title="7. 笔记"></a>7. 笔记</h5><ul><li><a href="https://mermaid-js.github.io/mermaid/#/">mermaid文档</a>.</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/z%E6%9D%A1%E4%BB%B6%E7%BF%BB%E8%AF%91/"/>
    <url>/2020/10/11/z%E6%9D%A1%E4%BB%B6%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<ul><li>$$f^{‘}(x)=0\stackrel{有区间}{\Longrightarrow}\begin{cases}费马定理\罗尔定理\end{cases}$$.</li><li>$f(b)-f(a)\begin{cases}\stackrel{f(b)-f(a)=0}{==\Longrightarrow}f^{‘}(\xi)=0,罗尔定理\\stackrel{f(b)-f(a)\not=0}{==\Longrightarrow}f^{‘}(\xi)=\frac{f(b)-f(a)}{b-a},拉氏定理\end{cases}$.</li><li>极值$\Longleftarrow$区间内的最值</li><li>函数的奇偶性【只用研究一般区间】</li></ul><a id="more"></a>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/YouSanAI%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/11/YouSanAI%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h5 id="1-租GPU"><a href="#1-租GPU" class="headerlink" title="1.租GPU"></a>1.租GPU</h5><p><a href="https://www.yousanai.cn/home">主页</a></p><h5 id="2-邮箱收到登陆信息"><a href="#2-邮箱收到登陆信息" class="headerlink" title="2.邮箱收到登陆信息"></a>2.邮箱收到登陆信息</h5><p><img src="https://user-images.githubusercontent.com/49241298/72658758-98665900-39f0-11ea-9756-bbc9cb8188d3.jpg" alt="1"></p><p>jupyter不能登陆，解决方法：使用ssh登陆（用Xshell软件）</p><a id="more"></a><h5 id="3-下载配置XShell"><a href="#3-下载配置XShell" class="headerlink" title="3.下载配置XShell"></a>3.下载配置XShell</h5><ul><li>下载地址：<a href="https://www.netsarang.com/en/xshell/">XShell</a></li><li>安装，一路下一步，我是安装在D:\XShell_Program，数据放在D:\XShell_Data</li></ul><h5 id="4-使用XShell"><a href="#4-使用XShell" class="headerlink" title="4.使用XShell"></a>4.使用XShell</h5><ul><li><p>打开，</p></li><li><p>新建会话，输入主机和端口号</p><p><img src="https://user-images.githubusercontent.com/49241298/72658759-98feef80-39f0-11ea-949b-26d9268a05b2.jpg" alt="2"></p></li><li><p>设置用户登录身份验证：</p><p>用户名用root（好像随便取也行，没有试），密码就是邮件里ssh的默认密码。</p><p><img src="https://user-images.githubusercontent.com/49241298/72658753-9603ff00-39f0-11ea-99f3-dd75551608e0.png" alt="3"></p></li><li><p>连接</p><p><img src="https://user-images.githubusercontent.com/49241298/72658757-97cdc280-39f0-11ea-9669-fbc9f551f84c.jpg" alt="4"></p></li><li><p>jupyter notebook password好像没用，用jupyter notebook list：</p><p><img src="https://user-images.githubusercontent.com/49241298/72658756-97352c00-39f0-11ea-9540-79d787ab110b.jpg" alt="5"></p></li><li><p>复制token至jupyter notebook界面中（地址为<a href="http://111.44.254.164:20048/%EF%BC%8C%E4%B8%8D%E5%8A%A0token%EF%BC%89%EF%BC%9A">http://111.44.254.164:20048/，不加token）：</a></p></li><li><p>登录成功</p></li></ul><h5 id="5-切换jupyter-notebook的环境"><a href="#5-切换jupyter-notebook的环境" class="headerlink" title="5.切换jupyter notebook的环境"></a>5.切换jupyter notebook的环境</h5><ul><li><p>在命令行里面可以用conda activate python367切换至367环境，但notebook仍是base。方法：</p><pre><code class="hljs python">conda install ipykernelpython -m ipykernel install --user --name python367 --display-name <span class="hljs-string">&quot;Python [conda env:367]&quot;</span></code></pre></li></ul><h5 id="6-Pytorch版本-待解决"><a href="#6-Pytorch版本-待解决" class="headerlink" title="6.Pytorch版本(待解决)"></a>6.Pytorch版本(待解决)</h5><blockquote><p>!pip3 install torch==1.3.1+cu92 torchvision==0.4.2+cu92 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a><br>torch.__version__</p></blockquote><p>但发现仍然是1.2的Torch，查看目录发现，装到了3.5的里面：</p><p><img src="https://user-images.githubusercontent.com/49241298/72658754-969c9580-39f0-11ea-8d04-530bd0d93392.png" alt="6"></p><pre><code class="hljs python"><span class="hljs-comment"># python367环境目录  /root/anaconda3/envs/python367</span></code></pre><p>……..</p><h5 id="7-Detectron与Python版本"><a href="#7-Detectron与Python版本" class="headerlink" title="7.Detectron与Python版本"></a>7.Detectron与Python版本</h5><pre><code class="hljs python"><span class="hljs-comment"># ERROR: Package &#x27;detectron2&#x27; requires a different Python: 3.5.2 not in &#x27;&gt;=3.6&#x27;</span></code></pre><h5 id="8-更换pip镜像"><a href="#8-更换pip镜像" class="headerlink" title="8.更换pip镜像"></a>8.更换pip镜像</h5><pre><code class="hljs python">!pqi ls <span class="hljs-comment"># 查看镜像地址</span>!pqi use aliyun <span class="hljs-comment">#</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/UIBE_tas_Tool_DEMO/"/>
    <url>/2020/10/11/UIBE_tas_Tool_DEMO/</url>
    
    <content type="html"><![CDATA[<h5 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h5><ul><li><a href="https://www.jianshu.com/p/dc932de13a6e">结构化数据操作——Xpath、BS4、正则</a></li></ul><h5 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h5><ul><li><p>创建requests.Session</p><pre><code class="hljs python">self.s = session</code></pre></li></ul><a id="more"></a><ul><li><p>POST提交请求</p><pre><code class="hljs python"><span class="hljs-comment"># 设置评分</span>params2 = &#123;<span class="hljs-string">&quot;__EVENTTARGET&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment"># 注释掉的为非必须字段</span>           <span class="hljs-comment"># &quot;__EVENTARGUMENT&quot;: &quot;&quot;,</span>           <span class="hljs-comment"># &quot;__LASTFOCUS&quot;: &quot;&quot;,</span>           <span class="hljs-comment"># &quot;__VIEWSTATE&quot;: &quot;&quot;,</span>           <span class="hljs-comment"># &quot;rbtnlType&quot;: &quot;4&quot;,</span>           <span class="hljs-string">&quot;btnSubmit&quot;</span>: <span class="hljs-string">&quot;批阅&quot;</span>          &#125;<span class="hljs-keyword">for</span> cbn <span class="hljs-keyword">in</span> lst_checkbox_name:    params2[cbn] = <span class="hljs-string">&#x27;on&#x27;</span>     <span class="hljs-comment"># 勾选，则设置为&#x27;on&#x27;；清空则设置为&#x27;&#x27;</span><span class="hljs-keyword">for</span> sbn <span class="hljs-keyword">in</span> lst_scorebox_name:    params2[sbn]=random.choice(self.lst_score)      <span class="hljs-comment"># 设置评分</span>self.s.post(homework_aim_url, data=params2)</code></pre></li><li><p>按钮</p><pre><code class="hljs python">self.button3 = Button(self.frame, text=<span class="hljs-string">&quot;批阅&quot;</span>, command=self.readover, width=<span class="hljs-number">6</span>, height=<span class="hljs-number">1</span>, bg=<span class="hljs-string">&#x27;red&#x27;</span>, fg=<span class="hljs-string">&#x27;white&#x27;</span>)self.button3.grid(row=<span class="hljs-number">4</span>, column=<span class="hljs-number">0</span>)</code></pre></li><li><p>复选框</p><pre><code class="hljs python">self.download_all = IntVar()self.check_button = Checkbutton(self.frame, text=<span class="hljs-string">&#x27;下载所有作业&#x27;</span>, variable=self.download_all)self.check_button.grid(row=<span class="hljs-number">5</span>, column=<span class="hljs-number">0</span>)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/test2/"/>
    <url>/2020/10/11/test2/</url>
    
    <content type="html"><![CDATA[<ul><li><p>1</p><ul><li><pre><code class="java">public//列表顺延的缩进[实际是空格缩进]<pre><code class="hljs">  ```java两个空格缩进，java</code></pre></code></pre></li></ul></li></ul><pre><code class="hljs java">没有缩进的java</code></pre><p>​    ```Tab缩进之后，输入java没有提示</p><p>​    ```Tab缩进之后，强行java的话，会变成高亮</p><p>一</p><p>​    双行换行后用Tab，会添加断点</p><p>一<br>    单行换行后用Tab，是长箭头</p><p>一</p><p>​    双行换行后四个空格，会添加断点</p><p>一<br>    单行换行后四个空格，四个空格</p><p>多个空格           哈哈</p><blockquote><p>引用</p><p>双行换行<br>单行换行</p></blockquote><ul><li>1的的<ul><li>2的的<ul><li>3都是都是所多所多</li></ul></li><li>2稍等稍等是否水电费</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/test/"/>
    <url>/2020/10/11/test/</url>
    
    <content type="html"><![CDATA[<ul><li><p>小标题下。对整个代码块缩进</p><pre><code class="hljs python">print(<span class="hljs-string">&#x27;缩进是两个空格&#x27;</span>)</code></pre></li></ul><p>非小标题下。对整个代码块缩进<br>  <pre><code class="hljs python">print(<span class="hljs-string">&#x27;缩进是两个空格&#x27;</span>)</code></pre></p><p>仅对代码内容缩进</p><pre><code class="hljs python">print(<span class="hljs-string">&#x27;缩进是Tab&#x27;</span>)</code></pre><p>没有缩进的代码</p><pre><code class="hljs python">print(<span class="hljs-string">&#x27;啥都没有的python&#x27;</span>)</code></pre><p>试验：<br>  <code>哈``python   print(&#39;缩进是两个空格&#39;)   ``啊</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/Streamlit%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/11/Streamlit%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>安装：<br>pip install streamlit<br>（pip install streamlit –user）</p></li><li><p>配置系统变量、环境变量</p></li><li><p>使用</p><ul><li>进入对应目录</li><li>（第一次可能需要输入邮箱）</li><li>运行</li></ul></li></ul><a id="more"></a><ul><li><p>streamlit hello，运行hello程序</p><ul><li><p>streamlit run test.py，运行一个py程序</p><p><img src="https://user-images.githubusercontent.com/49241298/72662172-1a6d7680-3a1f-11ea-8597-307ec065ab63.png"></p></li><li><p>运行之后应该会自动打开对应网页，或手动输入：<a href="http://localhost:8501/">test·Streamlit</a></p><p><img src="https://user-images.githubusercontent.com/49241298/72662207-7afcb380-3a1f-11ea-9283-062439ce8282.png"></p></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/PCA/"/>
    <url>/2020/10/11/PCA/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://www.coursera.org/learn/machine-learning/home/week/8">Coursera机器学习</a></li><li><a href="http://setosa.io/ev/principal-component-analysis/">PCA可视化网站</a></li></ul><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ol><li>主成分分析（Principal component analysis，PCA）是一种常用的无监督学习方法。</li><li>PCA是通过<code>正交变换</code>将<code>线性相关的变量</code>转换为<code>少数线性无关的变量</code>，这些线性无关的变量称为<code>主成分</code>。因为主成分数量通常小于原变量的个数，所以PCA属于<code>降维方法</code>。</li><li>PCA的常见应用为：通过降维，可以提高算法的运行速度，也可以可视化高维的数据。</li></ol><a id="more"></a><h4 id="2-数学角度"><a href="#2-数学角度" class="headerlink" title="2.数学角度"></a>2.数学角度</h4><h5 id="2-1几何意义（李航-p-298-）"><a href="#2-1几何意义（李航-p-298-）" class="headerlink" title="2.1几何意义（李航$p_{298}$）"></a>2.1几何意义（李航$p_{298}$）</h5><ul><li>主成分分析旨在选取<code>正交变换中方差最大</code>的变量，即在旋转变换中选取离样本点<code>距离平方和最小</code>的轴为第一主成分，第二第三同理。</li><li>如图，有5个原始数据点，坐标分别为：$(2,2),(2,6),(6,2),(6,6),(8,8)$；<a name="anchor1"></a><br>通过正交变换之后，坐标约等于$(-4,0),(-1.1,2.8),(-1.1,-2.8),(1.7,0),(4.5,0)$<br><img src="https://img-blog.csdnimg.cn/2019082410104065.png" alt="在这里插入图片描述"></li></ul><h5 id="2-2公式表达（李航-p-299-）"><a href="#2-2公式表达（李航-p-299-）" class="headerlink" title="2.2公式表达（李航$p_{299}$）"></a>2.2公式表达（李航$p_{299}$）</h5><ul><li><p><code>1.变量声明：</code><br>设X_train为m×n的样本矩阵<code>(m个样本，n个特征)</code>，其<code>转置</code>为$X$ (n*m)，$\sum$为$X$的协方差矩阵，$\sum$的特征值为$λ_1≥λ_2≥λ_3…≥λ_j≥0$，对应的<code>单位特征向量</code>$\alpha_1,\alpha_2,\alpha_3…\alpha_j$。</p></li><li><p><code>2.结论：</code><br>$X$的第$k$个主成分为：$$y_k=\alpha_k^TX =\left[\begin{matrix}\alpha_{1k}\\alpha_{2k}\.\.\\alpha_{jk}\end{matrix}\right]^T*\left[\begin{matrix}x_1\x_2\x_3\.\.\x_j\end{matrix}<br>\right]=\alpha_{1k}x_1+\alpha_{2k}x_2+…+\alpha_{jk}x_j,k=1,2,…,j$$</p></li></ul><p>其中，$x_1$,$x_2$,$x_3$…均为1*m的向量。</p><ul><li><p>$X$的第k个主成分的方差为：<br>$var(y_k)=\alpha_k^TΣ\alpha_k=λ_k,k=1,2,…,j$，即协方差矩阵$Σ$的第$k$个特征值。<br>协方差为：<br>$cov(y_a,y_b)=\alpha_a^TΣ\alpha_b,a=1,2,…,j,b=1,2,…,j$<br>且所有主成分Y的方差之和等于原矩阵X的方差之和。</p></li><li><p><code>注：协方差矩阵C的计算：</code><br>假设X为<code>n*m</code>的矩阵，则协方差矩阵$Σ$为：<br>$$<br>\begin{aligned}<br>Σ&amp;=\frac{1}{m-1}XX^T\<br>&amp;=<br>\frac{1}{m-1}\left[\begin{matrix}<br>x_1^{(1)}&amp;x_2^{(1)}&amp;…\<br>x_1^{(2)}&amp;…&amp;…\<br>.\<br>x_1^{(m)}<br>\end{matrix}\right]<br>×<br>\left[\begin{matrix}<br>x_1^{(1)}&amp;x_1^{(2)}&amp;…\<br>x_2^{(1)}&amp;…&amp;…\<br>.\<br>x_n^{(1)}<br>\end{matrix}\right]\<br>\end{aligned}<br>$$</p></li></ul><h4 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h4><h4 id="4-PCA代码实现"><a href="#4-PCA代码实现" class="headerlink" title="4.PCA代码实现"></a>4.PCA代码实现</h4><h5 id="4-1源码实现"><a href="#4-1源码实现" class="headerlink" title="4.1源码实现"></a>4.1源码实现</h5><ul><li><p>PCA的步骤（已有m条n维数据<code>X_train</code>）：</p><p>1.将X_train按列(即<code>属性</code>)进行零均值化，得$nor_X$    #$shape=(m,n)$；</p><p>2.求协方差矩阵$\sum=\frac{1}{m-1}nor_X^Tnor_X$；<br>3.求协方差矩阵$\sum$的<code>特征值eig_val</code>和<code>对应特征向量eig_vec</code>；<br>4.根据特征值<code>降序</code>将对应特征向量从左至右组成矩阵，取<code>前k列</code>组成矩阵$P$    #$shape=(n,k)$；<br>5.降维之后的数据pca_X_train=$nor_X×P$     #$shape=(m*k)$</p><p>ps:协方差矩阵的无偏估计的系数为$\frac{1}{m-1}$，但无论$\sum$的系数不影响最终的特征向量，只影响特征值，因此实际计算时也可以省略$\frac{1}{m-1}$。但<code>np.cov是按照m-1计算的</code>,所以这里我们也用$\frac{1}{m-1}$。</p></li><li><p>代码：</p><pre><code class="hljs python"><span class="hljs-comment"># X为要降维的数据，类型为DataFrame</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pca</span>(<span class="hljs-params">X,k</span>):</span>    n_samples,n_features=X.shape    <span class="hljs-comment"># 零均值化</span>    nor_X=X-np.mean(X,axis=<span class="hljs-number">0</span>)    <span class="hljs-comment"># 求协方差矩阵</span>    C=<span class="hljs-number">1</span>/(n_samples<span class="hljs-number">-1</span>)*np.dot(np.transpose(nor_X),nor_X)    <span class="hljs-comment"># 求特征值和特征向量</span>    eig_val,eig_vec=np.linalg.eig(C)    <span class="hljs-comment"># 组成矩阵，并保留k个向量</span>    eig_pairs=[(np.abs(eig_val[i]),eig_vec[:,i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_features)]    eig_pairs.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>],reverse=<span class="hljs-literal">True</span>)    feature=np.array([ele[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> eig_pairs[:k]])    <span class="hljs-comment"># 将原数据转换</span>    data=np.dot(nor_X,np.transpose(feature))    <span class="hljs-keyword">return</span> data</code></pre><p>还用我们前面的数据：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pdX_train=[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],         [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],         [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],         [<span class="hljs-number">6</span>,<span class="hljs-number">6</span>],         [<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]]X_train=pd.DataFrame(X_train,columns=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])</code></pre><p>则PCA转化之后的数据，可见结果和之前的图<a href="#anchor1">之前的图</a>相符合。</p><pre><code class="hljs python"><span class="hljs-comment">#其中数字2表示：保留2个主成分</span>PCA_X_train=pd.DataFrame(pca(X_train,<span class="hljs-number">2</span>))print(PCA_X_train)<span class="hljs-comment"># Output:</span><span class="hljs-comment">#           0             1</span><span class="hljs-comment"># 0 -3.959798  3.920609e-16</span><span class="hljs-comment"># 1 -1.131371  2.828427e+00</span><span class="hljs-comment"># 2 -1.131371 -2.828427e+00</span><span class="hljs-comment"># 3  1.697056 -1.630506e-16</span><span class="hljs-comment"># 4  4.525483 -4.961175e-16</span></code></pre><h5 id="4-2使用sklearn验证"><a href="#4-2使用sklearn验证" class="headerlink" title="4.2使用sklearn验证"></a>4.2使用sklearn验证</h5></li></ul><p>使用sklearn的PCA验证：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> nppca=PCA(n_components=<span class="hljs-number">1</span>)pca.fit(X_train)print(pca.transform(X_train))<span class="hljs-comment"># Output:</span><span class="hljs-comment"># [[-3.95979797]</span><span class="hljs-comment">#  [-1.13137085]</span><span class="hljs-comment">#  [-1.13137085]</span><span class="hljs-comment">#  [ 1.69705627]</span><span class="hljs-comment">#  [ 4.5254834 ]]</span></code></pre><h4 id="5-使用PCA的一些建议"><a href="#5-使用PCA的一些建议" class="headerlink" title="5.使用PCA的一些建议"></a>5.使用PCA的一些建议</h4><h5 id="5-1优点"><a href="#5-1优点" class="headerlink" title="5.1优点"></a>5.1优点</h5><ul><li>PCA的参数<code>均通过拟合train</code>来获得，之后在cross_validation或test上用<code>拟合好的PCA映射</code>来完成验证或预测。</li><li>使用PCA可以大概把n_features减少1/10甚至1/5，而不影响性能（如accuracy）。</li><li>PCA的两种主要应用：</li></ul><p>1.Compression（数据压缩→<code>提高算法的速度</code>）<br>2.Visualization（降维之后可视化），通常降至2D或3D</p><h5 id="5-2PCA的误用"><a href="#5-2PCA的误用" class="headerlink" title="5.2PCA的误用"></a>5.2PCA的误用</h5><ul><li>在处理过拟合问题时，虽然使用PCA降维可能会有一定的效果，但是<code>更推荐使用正则项</code>。因为PCA在降维时没有考虑标签列，这样做可能会<code>损失一些重要的信息</code>。而使用正则项时，很容易打到PCA的效果，而且因为$J(\theta)$中包含标签列，所以并不会忽略标签列的信息。</li><li>在设计机器学习系统时，不应该先把PCA设置为一个步骤。应该先使用<code>原始数据</code>来进行拟合预测。而当有<code>足够的原因</code>，如磁盘不够，运算太太太慢等，才考虑使用PCA。</li></ul><h4 id="6-计算协方差的两种方法"><a href="#6-计算协方差的两种方法" class="headerlink" title="6.计算协方差的两种方法"></a>6.计算协方差的两种方法</h4><p>比如我们有如下数据：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npX=[[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],   [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],   [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>],   [<span class="hljs-number">6</span>,<span class="hljs-number">6</span>],   [<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]]X=X-np.mean(X,axis=<span class="hljs-number">0</span>)print(X)</code></pre><ul><li>方法1：$\frac{1}{m-1}X^TX$：</li></ul><pre><code class="hljs python"><span class="hljs-number">1</span>/(len(X)<span class="hljs-number">-1</span>)*np.dot(np.transpose(X),X)</code></pre><ul><li>方法2：使用numpy的cov函数：</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 注意要将X转置，因为在cov接受的参数矩阵里：行是特征，列是记录</span>print(np.cov(X.T))<span class="hljs-comment"># Output:</span><span class="hljs-comment"># [[7.2 3.2]</span><span class="hljs-comment">#  [3.2 7.2]]</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PCA</tag>
      
      <tag>主成分分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/Logistic-Regression/"/>
    <url>/2020/10/11/Logistic-Regression/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li>Coursera机器学习</li></ul><h4 id="一、假设函数"><a href="#一、假设函数" class="headerlink" title="一、假设函数"></a>一、假设函数</h4><p>$$<br>\begin{aligned}<br>h_\theta(x)&amp;=sigmoid(\theta^Tx)\<br>&amp;=\frac{1}{1+e^{-\theta^Tx}}<br>\end{aligned}<br>$$</p><ul><li>Octave代码</li></ul><pre><code class="hljs octave">function g &#x3D; sigmoid(z)g&#x3D;1.&#x2F;(1+e.^(-z));end</code></pre><h4 id="二、损失函数及求导"><a href="#二、损失函数及求导" class="headerlink" title="二、损失函数及求导"></a>二、损失函数及求导</h4><a id="more"></a><h5 id="1-表达方式一-求和表达式-："><a href="#1-表达方式一-求和表达式-：" class="headerlink" title="1.表达方式一(求和表达式)："></a>1.表达方式一(求和表达式)：</h5><ul><li>$J(\theta )$：</li></ul><p>如果仍使用Linear Regression的损失函数的形式：$J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})$，则sigmoid的高度非线性会使$J(\theta)$的曲线变为非凸性，导致梯度下降求解困难，因此引入新的损失函数**(为了简化，省略了循环变量$i$)**：</p><p>$$<br>J(\theta)=-\frac{1}{m}\sum_i[ylog(h_\theta(x)+(1-y)log(1-h_\theta(x))]<br>$$</p><p>其中，当$y=1$时，$log(h_\theta(x))$的图像如下：</p><p>当$y=0$时，$log(1-h_\theta(x))$的图像如下：</p><ul><li>对$\theta$求导：</li></ul><p>$$<br>\nabla_\theta J(\theta)=-\frac{1}{m}\sum_i[(h_\theta(x)-y)x]<br>$$</p><ul><li>梯度下降：</li></ul><p>$$<br>\theta:=\theta-\frac{\alpha}{m}\sum_i[(h_\theta(x)-y)x]<br>$$</p><h5 id="2-表达方式二-向量表达式-："><a href="#2-表达方式二-向量表达式-：" class="headerlink" title="2.表达方式二(向量表达式)："></a>2.表达方式二(向量表达式)：</h5><ul><li>$J(\theta)$</li></ul><p>$$<br>J(\theta)=-\frac{1}{m}[y^Tlog(sigmoid(X\theta))+(1-y)^Tlog(1-sigmoid(X\theta))]<br>$$</p><ul><li>对$\theta$求导</li></ul><p>$$<br>\nabla_\theta J(\theta)=-\frac{1}{m}[X^T(sigmoid(X\theta)-y)]<br>$$</p><ul><li>梯度下降：</li></ul><p>$$<br>\theta:=\theta-\frac{\alpha}{m}[X^T(sigmoid(X\theta)-y)]<br>$$</p><h5 id="3-梯度下降代码-Octave"><a href="#3-梯度下降代码-Octave" class="headerlink" title="3.梯度下降代码(Octave)"></a>3.梯度下降代码(Octave)</h5><pre><code class="hljs octave">function [J, grad] &#x3D; costFunction(theta, X, y)m &#x3D; length(y); % number of training examplesJ &#x3D; 1&#x2F;m*(-(y&#39;)*log(sigmoid(X*theta))-(1-y)&#39;*log(1-sigmoid(X*theta))); %计算代价函数grad &#x3D; 1&#x2F;m*X&#39;*(sigmoid(X*theta)-y);  %求梯度,shape as zeros(size(theta))end</code></pre><h5 id="4-注意"><a href="#4-注意" class="headerlink" title="4.注意"></a>4.注意</h5><p>值得注意的是，尽管表达式一和二中的$\theta$是一样的，均为$n*1$维的向量；但在表达方式一中，单个样本的假设函数值为$\theta^Tx^{(i)}$，$\theta$在前；而在表达式二中，<code>全部样本</code>的假设函数值组成的向量为$X\theta$，$\theta$在后。但本质上是一致的，详细解释↓：</p><p>我们平常在表示一个长度为$n$的向量$\vec{a}$时，如果没有明确指明是$n<em>1$的还是$1</em>n$的，则默认为$n*1$的，即$$\vec{a}=\left[\begin{matrix}1\2\.\.\n\end{matrix}\right]$$。所以同理，单个样本$x^{(i)}=\left[\begin{matrix}x_1^{(i)}\x_2^{(i)}\,\,\x_n^{(i)}\end{matrix}\right]$，总样本矩阵$X=\left[\begin{matrix}x^{(1)T}\x^{(2)T}\,\,\x^{(i)T}\end{matrix}\right]$，$\theta=\left[\begin{matrix}\theta_1\\theta_2\,\,\\theta_n\end{matrix}\right]$，因此：</p><p>$$<br>X\theta=\left[\begin{matrix}x^{(1)^T}\x^{(2)T}\.\.\x^{(i)T}\end{matrix}\right]*\theta=\left[\begin{matrix}x^{(1)^T}\theta\x^{(2)T}\theta\.\.\x^{(i)T}\theta\end{matrix}\right]=\left[\begin{matrix}\theta^Tx^{(1)}\\theta^Tx^{(2)}\.\.\\theta^Tx^{(i)}\end{matrix}\right]<br>$$</p><h4 id="三、加惩罚项的损失函数及求导"><a href="#三、加惩罚项的损失函数及求导" class="headerlink" title="三、加惩罚项的损失函数及求导"></a>三、加惩罚项的损失函数及求导</h4><h5 id="1-表达方式一："><a href="#1-表达方式一：" class="headerlink" title="1.表达方式一："></a>1.表达方式一：</h5><ul><li>$J(\theta )_{Reg}$：</li></ul><p>$$<br>\begin{aligned}<br>J(\theta)<em>{Reg}&amp;=J(\theta)+Reg\<br>&amp;=-\frac{1}{m}\sum</em>{i=1}^m[ylog(h_\theta(x)+(1-y)log(1-h_\theta(x))]-\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2\<br>\end{aligned}<br>$$</p><ul><li><p>求导<br>$$<br>\nabla_\theta J(\theta)_{Reg}=-\frac{1}{m}\sum_i[(h_\theta(x)-y)x]-\frac{\lambda}{m}\sum_j\theta_j<br>$$</p></li><li><p>梯度下降</p></li></ul><p>$$<br>\begin{aligned}<br>\theta_j:&amp;=\theta_j-\frac{\alpha}{m}\sum_i[(h_\theta(x)-y)x]-\frac{\lambda\alpha}{m}\theta_j\<br>&amp;=\theta_j(1-\lambda\frac{\alpha}{m})-\frac{\alpha}{m}\sum_i[(h_\theta(x)-y)x]<br>\end{aligned}<br>$$</p><center>↑</center>​        可以发现，$\theta_j$比加惩罚项之前更小了$(1-\lambda\frac{\alpha}{m}<1)$。<h5 id="2-表达方式二："><a href="#2-表达方式二：" class="headerlink" title="2.表达方式二："></a>2.表达方式二：</h5><ul><li>$J(\theta)_{Reg}$：</li></ul><p>$$<br>J(\theta)_{Reg}=-\frac{1}{m}[y^Tlog(sigmoid(X\theta))+(1-y)^Tlog(1-sigmoid(X\theta))]-\frac{\lambda}{2m}\theta^2<br>$$</p><ul><li>对$\theta$求导</li></ul><p>$$<br>\nabla_\theta J(\theta)=-\frac{1}{m}[X^T(sigmoid(X\theta)-y)]-\frac{\lambda E}{m}\theta<br>$$</p><ul><li>梯度下降：</li></ul><p>$$<br>\begin{aligned}<br>\theta:&amp;=\theta-\frac{\alpha}{m}[X^T(sigmoid(X\theta)-y)]-\alpha\frac{\lambda E}{m}\theta\<br>&amp;=\theta(1-\alpha\frac{\lambda E}{m})-\frac{\alpha}{m}[X^T(sigmoid(X\theta)-y)]<br>\end{aligned}<br>$$</p><h5 id="3-梯度下降代码-Octave-1"><a href="#3-梯度下降代码-Octave-1" class="headerlink" title="3.梯度下降代码(Octave)"></a>3.梯度下降代码(Octave)</h5><pre><code class="hljs octave">function [J, grad] &#x3D; costFunctionReg(theta, X, y, lambda)m &#x3D; length(y); % number of training examplesJ &#x3D; 1&#x2F;m*(-(y&#39;)*log(sigmoid(X*theta))-(1-y)&#39;*log(1-sigmoid(X*theta)))+(1&#x2F;(2*m))*lambda*(sum(theta .^2) - theta(1)^2); %正规化时不用对θ1正规化？grad &#x3D; 1&#x2F;m*X&#39;*(sigmoid(X*theta)-y)+lambda*theta&#x2F;m;grad(1) &#x3D; grad(1)-lambda*theta(1)&#x2F;m;end</code></pre><h4 id="四、从概率角度解释损失函数"><a href="#四、从概率角度解释损失函数" class="headerlink" title="四、从概率角度解释损失函数"></a>四、从概率角度解释损失函数</h4><ul><li>假设有一个二分类问题：0或1；<br>我们知道在逻辑回归中，$h_\theta(x)$ 的本质是<code>概率值</code>，所以我们用概率表示$h_\theta$的值，且$p_{y=0}=1-p$；<br>所以第i个样本的概率分布函数可以表示为：<br>$$<br>P(y^{(i)}|x^{(i)})=\begin{cases}<br>p &amp; ,y^{(i)}=1 \<br>1-p &amp;  ,y^{(i)}=0<br>\end{cases}<br>$$</li><li>我们可以把上式简化为：$P(y^{(i)}|x^{(i)})=p^{y^{(i)}}*(1-p)^{1-y^{(i)}}$，注意上标(i)表示<code>属于第i个样本</code>，而$p^{y}$则表示正常的<code>p的y次方</code>；</li><li>所以全体样本的分布（即似然函数）为：$P_{总}=\prod_{i=1}^{m}[p^{y^{(i)}}*(1-p)^{1-y^{(i)}}]$<br>取对数（因为我们要求代价函数的最值，转化为ln函数方便计算）得：</li></ul><p>$$<br>对数似然函数：ln(P_{总}) = ln(\prod_{i=1}^{m}[p^{y^{(i)}}*(1-p)^{1-y^{(i)}}])=\sum_{i=1}^{m}[y^{(i)}ln(p)+(1-y^{(i)})ln(1-p)]<br>$$</p><ul><li>令$J(\theta)=-\frac{1}{m}ln(P_{总})$，所以<code>最大化似然估计即</code>等价于<code>最小化代价函数</code>。</li></ul><h4 id="五、代码补充："><a href="#五、代码补充：" class="headerlink" title="五、代码补充："></a>五、代码补充：</h4><ul><li>预测(Octave)</li></ul><pre><code class="hljs octave">function p &#x3D; predict(theta, X)m &#x3D; size(X, 1); % Number of training examplesp&#x3D;floor(sigmoid(X*theta).*2); %因为使用了floor()函数，所以函数值要扩大二倍end</code></pre><ul><li>分类结果可视化(Python)</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visualize_classifier</span>(<span class="hljs-params">model, X, y, ax=None, cmap=<span class="hljs-string">&#x27;rainbow&#x27;</span></span>):</span>    <span class="hljs-comment">#既可以在ax上画，也可以在figure上画</span>    ax = ax <span class="hljs-keyword">or</span> plt.gca()        <span class="hljs-comment">#训练集-散点图</span>    ax.scatter(X[:, <span class="hljs-number">0</span>], X[:, <span class="hljs-number">1</span>], c=y, s=<span class="hljs-number">30</span>, cmap=cmap)        ax.axis(<span class="hljs-string">&#x27;tight&#x27;</span>)<span class="hljs-comment">#调整axes之间的间距</span>    ax.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<span class="hljs-comment">#隐藏坐标轴</span>        xlim = ax.get_xlim()    ylim = ax.get_ylim()    <span class="hljs-comment">#对于底盘上每一个点进行分类</span>    model.fit(X, y)    xx, yy = np.meshgrid(np.linspace(*xlim, num=<span class="hljs-number">200</span>),np.linspace(*ylim, num=<span class="hljs-number">200</span>))    Z = model.predict(np.c_[xx.ravel(), yy.ravel()]).reshape(xx.shape)    <span class="hljs-comment">#根据分类画出底色</span>    n_classes = len(np.unique(y))    contours = ax.contourf(xx, yy, Z, alpha=<span class="hljs-number">0.3</span>,                           levels=np.arange(n_classes + <span class="hljs-number">1</span>) - <span class="hljs-number">0.5</span>,                           cmap=cmap)    <span class="hljs-comment">#当存在多个不同的数据集要可视化时，设置每个子图为自己的lim</span>    ax.set(xlim=xlim, ylim=ylim)</code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> pltX, y = make_blobs(n_samples=<span class="hljs-number">300</span>, centers=<span class="hljs-number">2</span>,                  random_state=<span class="hljs-number">0</span>, cluster_std=<span class="hljs-number">1.0</span>)model = LogisticRegression()visualize_classifier(model, X, y)</code></pre><center>结果↓</center>![1](https://user-images.githubusercontent.com/49241298/75753545-0038ef00-5d66-11ea-96b3-4b5868a76f6d.png)]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/Linear-SVM/"/>
    <url>/2020/10/11/Linear-SVM/</url>
    
    <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>SVM(Support Vector Machine)，相比于逻辑回归、神经网络，在处理复杂的非线性问题时，能够提供更清晰、更强大的方式，也拥有更强的可解释性；<br>SVM可以分为两大类：</p><ul><li>Linear SVM：<ul><li>线性可分SVM：当数据线性可分时，通过最大化硬间隔学习分类器；</li><li>线性SVM：当数据近似线性可分时，引入松弛变量，通过最大化软间隔学习分类器；</li></ul></li><li>Kernel SVM：<ul><li>非线性SVM：当数据线性不可分时，引入核函数，并最大化软间隔学习分类器。</li></ul></li></ul><p>本文涉及的内容是<code>Linear SVM</code>。</p><a id="more"></a><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h4><ul><li>损失函数$J(\theta)<em>{SVM}$：<br>我们之前学习LR时，并没有考虑$h_\theta(x)$的函数表达，只是将其当做一个概率常量；而在这里我们学习SVM时，我们将考虑$h_\theta(x)$的函数表达，并通过<code>修改</code>$J(\theta)</em>{LR}$中的部分项来获得另一种损失函数，即$J(\theta)<em>{SVM}$，具体过程如下：<br><code>1.首先</code>我们分段画出$J(\theta)</em>{LR}$的图像，如下图：<br><img src="https://img-blog.csdnimg.cn/20190703214047333.png" alt="在这里插入图片描述"><br><code>2.然后</code>用两条<code>品红色的折线</code>（函数表达式记为$cost_1(\theta^Tx^{(i)})$和$cost_0(\theta^Tx^{(i)})$）近似替代LR中的部分项(即$-logh_\theta(x)$和$-log(1-h_\theta(x))$)；<em>品红色折线称为合页函数（Hinge Function）</em>；<br><code>3.这样</code>我们得到了一个新的函数$J(\theta)^{‘}=\frac{1}{m}\sum_{i=1}^{m}[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{λ}{2m}\sum_{j=1}^{n}\theta_j^2$；<br><code>4.之后</code>将$J(\theta)^{‘}$中的常数$\frac{1}{m}$去掉，去掉$λ$，并在$cost_1(\theta^Tx^{(i)})$前面乘上另一个系数<code>C</code>，就得到了SVM的损失函数$J(\theta)<em>{SVM}$：<br>$$J(\theta)</em>{SVM}=C\sum_{i=1}^{m}[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{1}{2}\sum_{j=1}^{n}\theta_j^2$$<br>另外一点值得注意的是，在LR中，我们通过<code>λ</code>来权衡A和B的权重，而在SVM中，我们通过<code>C</code>来权衡A和B的权重。</li><li>假设函数$h_\theta(x)$：<br>LR和SVM另一点不同的是，二者的假设函数不同；SVM<code>直接预测为0或为1</code>而非概率值；<br>即：$$h_\theta(x)=\begin{cases}<br>1&amp;,\theta^Tx≥0\<br>0&amp;,\theta^Tx&lt;0<br>\end{cases}$$<h4 id="3-分类效果："><a href="#3-分类效果：" class="headerlink" title="3.分类效果："></a>3.分类效果：</h4></li><li>和LR相比，SVM对分类预测的条件要求更高：<br>对于LR而言，当$y^{(i)}=1$时，我们只要让$\theta^Tx≥0$就可以将其预测为正类；<br>而对于SVM，当$y^{(i)}=1$时，我们需要$\theta^Tx≥1$才将其预测为正类；<br>效果下如图：对于LR，最后得出的分界线可能是<font color="red">红线</font>或<font color='green'>绿线</font>，而SVM得出的可能是黑线。看起来，SVM的黑色分界线更靠谱一点，因为它没有过度贴近现有样本，而是选择折中，所以<code>更不容易发生过拟合</code>的问题。<br>具体原因看<a href="https://blog.csdn.net/mofangchenyunfeng/article/details/94590687#title1">4.in terms of vector</a>。<br><img src="https://img-blog.csdnimg.cn/20190705211545518.png" alt="在这里插入图片描述"></li></ul><div id="title1" class="elementor-menu-anchor"></div>#### 4. in terms of vector（从向量角度看优化问题）- 向量内积在讲SVM的目标函数之前，我们先看一下其用到的知识——向量内积：如图，有两个列矩阵$u=\left[\begin{matrix}u_1\\u_2\end{matrix}\right]$和$v=\left[\begin{matrix}v_1\\v_2\end{matrix}\right]$，写成向量的形式：$\vec u=(u_1,u_2)$，$\vec v=(v_1,v_2)$。设$\vec v$在$\vec u$方向上的投影为$p$，夹角为$β$。$∴p=\sqrt{v_1^2+v_2^2}cos\beta$$∵\vec u*\vec v=\sqrt{u_1^2+u_2^2}\sqrt{v_1^2+v_2^2}cosβ=\sqrt{u_1^2+u_2^2}p$，且$u^Tv=u_1v_1+u_2v_2=\vec u*\vec v$$∴u^Tv=\sqrt{u_1^2+u_2^2}p$![在这里插入图片描述](https://img-blog.csdnimg.cn/20190704121254872.png?)- SVM的向量内积`1.`参考下图，对于SVM来说，当$y^{(i)}=1$时，为了`最小化`$J(\theta)$，我们要尽量使$J(\theta)^{(i)}$等于0，即令$\theta^Tx≥1$；因为$\theta^Tx=\theta_1x_1+...+\theta_nx_n=\vec \theta*\vec x=p^{(i)}||\theta||$，所以等价于$p^{(i)}||\theta||≥1$；`2.`而$J(\theta)_{SVM}=C\sum_{i=1}^{m}[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{1}{2}\sum_{j=1}^{n}\theta_j^2$，`前半部分CA=0`，所以$J(\theta)_{SVM}=\frac{1}{2}||\theta||^2$。`3.`为了$minimizeJ(\theta)$，需要让$\theta$最小。又∵$p^{(i)}||\theta||≥1$ ，∴需要使$p^{(i)}$更大。而$p^{(i)}$的几何含义就是$\vec x$在$\vec \theta$上的投影，也就是样本点$x$到 `法向量θ对应的超平面H`的距离。`4.`综上，$\theta^Tx≥1$最终导致的结果就是样本到分界线的`距离更大`。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190704121509176.png?)- 案例如下图，我们有一组`二分类数据集Input Data`，蓝点和红点表示负类和正类。分别用LR和Linear SVM拟合。可以看出，SVM的分界线与样本之间的距离更大，我们可以把这个距离称为`安全距离`。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706123421694.png?)之后用拟合好的LR和SVM对和Input Data同分布的另一组数据进行分类，可以发现，`LR分错了2个正类和2个负类`，`SVM分错了2个负类`。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190706123500374.png?)当然，并不是说SVM在任何时候拟合效果都比LR好，只是在此例中，我们可以直观地看出SVM分类具有大间隔的特性。<h4 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h4><p>Linear SVM是：用一个和$logh_\theta(x)<em>{LR}$<code>类似的折线函数</code>$Cost_1(\theta^Tx)$来替换$logh_\theta(x)</em>{LR}$，并获得一个新的损失函数$J(\theta)_{SVM}$。在$minJ(\theta)$的过程中实现了<code>大间隔</code>分类的效果。另外，通过<code>间隔最大化规则</code>学习到的分类器的泛化能力一般要比LR要强。<br>但不幸的是，在实际应用中，Linear SVM没比LR强多少，尽管Linear SVM也可以用于处理线性不可分的问题。<br>如图：<br><img src="https://img-blog.csdnimg.cn/20190718224221565.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190718224154308.png" alt="在这里插入图片描述"></p><h4 id="6-习题"><a href="#6-习题" class="headerlink" title="6.习题"></a>6.习题</h4><p>Consider the training set to the right, where “x” denotes positive examples ($y=1$) and “o” denotes negative examples ($y=0$). Suppose you train an SVM (which will predict 1 when $\theta_0 + \theta_1x_1 + \theta_2x_2 \geq 0$). What values might the SVM give for $\theta_0$, $\theta_1, an$d $\theta_2?<img src="http://spark-public.s3.amazonaws.com/ml/images/12.2-quiz-1-q.png" alt="re$d x"></p><p>$\theta_0=3,\theta_1=1,\theta_2=0$</p><p>$\theta_0=-3,\theta_1=1,\theta_2=0$</p><p>正确 </p><p>$\theta_0=3,\theta_1=0,\theta_2=1$</p><p>$\theta_0=-3,\theta_1=0,\theta_2=1$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/Linear-Regression/"/>
    <url>/2020/10/11/Linear-Regression/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li>Coursera机器学习</li><li><a href="https://www.cnblogs.com/alex-bn-lee/p/10297893.html">线性回归损失函数求导</a></li><li><a href="http://setosa.io/ev/ordinary-least-squares-regression/">可视化</a></li></ul><h4 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h4><p>”线性回归“又可以叫做“线性拟合”，，拟合效果图图：</p><h4 id="一、损失函数及求导："><a href="#一、损失函数及求导：" class="headerlink" title="一、损失函数及求导："></a>一、损失函数及求导：</h4><h5 id="1-表达方式一："><a href="#1-表达方式一：" class="headerlink" title="1.表达方式一："></a>1.表达方式一：</h5><p>假定： $$x^{(i)}:n<em>1$$，$$\theta:n</em>1$$，$$y^{(i)}:1*1$$；$$h_\theta(x^{(i)})=\theta^Tx^{(i)}$$</p><a id="more"></a><ul><li>损失函数$J(\theta)$：</li></ul><p>$$<br>\begin{aligned}<br>J(\theta)&amp;=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2\<br>&amp;=\frac{1}{2m}\sum_{i=1}^m(\theta^Tx^{(i)}-y^{(i)})^2<br>\end{aligned}<br>$$</p><ul><li>$J(\theta)$求导：</li></ul><p>$$<br>\begin{aligned}<br>\nabla_\theta J(\theta)&amp;=\frac{\partial J(\theta)}{\partial\theta}\<br>&amp;=\frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}<br>\end{aligned}<br>$$</p><h5 id="2-表达方式二："><a href="#2-表达方式二：" class="headerlink" title="2.表达方式二："></a>2.表达方式二：</h5><p>假定：$$X:m<em>n、b:n</em>1、y:m*1；h_b(X)=Xb$$</p><p>则损失函数$J(\theta)$如下：</p><p>$$<br>\begin{aligned}<br>J(b)&amp;=(Xb-y)^2\<br>&amp;=(Xb-y)^T(Xb-y)\<br>&amp;=(b^TX^T-y^T)(Xb-y)\<br>&amp;=b^TX^TXb-b^TX^Ty-y^TXb+y^Ty<br>\end{aligned}<br>$$<br>求导：<br>$$<br>\begin{equation*}<br>\begin{split}<br>\nabla_b J(b) &amp;= \nabla_b (b^T X^T Xb - b^T X^T y - y^T Xb + y^T y)\\ &amp;= \nabla_b (b^T X^T Xb) - \nabla_b (b^T X^T y) - \nabla_b (y^T Xb) + \nabla_b (y^T y)\\ &amp;= \nabla_b (b^T (X^T X)b) - \nabla_b (b^T (X^T y)) - \nabla_b ((y^T X)b) + 0\\ &amp;= (X^T X + (X^T X)^T)b - X^T y - (y^T X)^T\\ &amp;= 2 X^T X b - 2 X^T y\\ &amp;= 2 X^T (Xb-y) \end{split} \end{equation*}<br>$$</p><p>其中，常用的矩阵求导公式：</p><p>$\frac{\partial(AX)}{\partial X}=A^T$，$\frac{\partial(AX)}{\partial X^T}=A$，$\frac{\partial(X^TAX)}{\partial X}=AX+A^TX$，$\frac{\partial(X^Ta)}{\partial X}=a$</p><h5 id="3-损失函数代码-Octave"><a href="#3-损失函数代码-Octave" class="headerlink" title="3.损失函数代码(Octave)"></a>3.损失函数代码(Octave)</h5><pre><code class="hljs octave">%损失函数function J &#x3D; computeCost(X, y, theta)m &#x3D; length(y); % number of training examplesh&#x3D;X*theta;srqt&#x3D;(h-y).^2;J&#x3D;1&#x2F;(2*m)*sum(srqt);end</code></pre><h4 id="二、梯度下降求解-Gradient-Descent"><a href="#二、梯度下降求解-Gradient-Descent" class="headerlink" title="二、梯度下降求解(Gradient Descent)"></a>二、梯度下降求解(Gradient Descent)</h4><h5 id="1-迭代"><a href="#1-迭代" class="headerlink" title="1.迭代"></a>1.迭代</h5><p>$$<br>Repeat:{\<br>θ_j:=θ<em>j-α\frac{1}{m}\sum</em>{i=1}^{m}(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}\<br>}<br>$$</p><h5 id="2-Octave代码"><a href="#2-Octave代码" class="headerlink" title="2.Octave代码"></a>2.Octave代码</h5><pre><code class="hljs Octave">%梯度下降function [theta, J_history] &#x3D; gradientDescent(X, y, theta, alpha, num_iters)m &#x3D; length(y); % number of training examplesJ_history &#x3D; zeros(num_iters, 1);for iter &#x3D; 1:num_iters    h &#x3D; X * theta;    j &#x3D; h - y;    sums &#x3D; X&#39; * j;    delta &#x3D; 1 &#x2F; m * sums;     theta &#x3D; theta - alpha * delta;    J_history(iter) &#x3D; computeCost(X, y, theta);end</code></pre><h4 id="三、正规求解-Normal-Equation"><a href="#三、正规求解-Normal-Equation" class="headerlink" title="三、正规求解(Normal Equation)"></a>三、正规求解(Normal Equation)</h4><ul><li><p>$\theta=(X^TX)^{-1}X^Ty$，需要确保$X^TX^{-1}$可逆；</p><ul><li>矩阵$X^TX$不可逆的情况：<ul><li>Features线性相关(<code>必须线性相关</code>)： </li><li>$m≤n$</li></ul></li></ul></li></ul><h4 id="四、梯度下降和正规求解比较"><a href="#四、梯度下降和正规求解比较" class="headerlink" title="四、梯度下降和正规求解比较"></a>四、梯度下降和正规求解比较</h4><table><thead><tr><th align="left">Gradient Descent</th><th align="left">Normal Equation</th></tr></thead><tbody><tr><td align="left">需要选择参数$\alpha$</td><td align="left">不需要选择参数$\alpha$</td></tr><tr><td align="left">需要迭代多次</td><td align="left">不需要迭代，但需要确保矩阵$X$可逆</td></tr><tr><td align="left">$O (kn^2)$</td><td align="left">$O (n^3)$, 需要计算$(X^TX)^{-1}$</td></tr><tr><td align="left">n很大时也能较好地工作</td><td align="left">当n特别大时，计算缓慢。一般$n≤10000$时选择正规求解</td></tr></tbody></table><h4 id="五、评价指标"><a href="#五、评价指标" class="headerlink" title="五、评价指标"></a>五、评价指标</h4><ul><li>评价标准：<br>Linear Regression常用<code>决策系数(coefficient of determination)</code>：<br>$R^2=\frac{SSR}{SST}=1-\frac{SSE}{SST}$，其中：</li></ul><p><em>SST(Sum of Squares for Total)</em>=$$\sum_{i=1}^{m}(y_i-\overline{y_i})^2$$，表示数据的<code>总方差</code>；<br><em>SSR(Sum of Squares for Regression)</em>= $\sum_{i=1}^{m}(\hat{y_i}-\overline{y_i})^2$，表示<code>已被模型（/自变量）解释的方差</code>；<br><em>SSE(Sum of squares for Error)</em>=$\sum_{i=1}^{m}(\hat{y_i}-y_i)^2$，<code>未被模型解释的方差（/成本）</code>；</p><blockquote><p>因为线性回归的损失函数为：<br>$$<br>\begin{aligned}J(θ)&amp;=\frac{1}{2m}\sum_{i=1}^{m}( h_θ({x^{(i)}} )-y^{(i)})^2\<br>&amp;=\frac{1}{2m}\sum_{i=1}^{m}(\hat{y}-y)^2<br>\end{aligned}$$<br>所以当最小化$J(\theta)$时，有$\sum_{i}y=\sum_{i}\hat{y}$，由此可进一步得到：<br>$$\sum_{i}(\hat{y}-\overline{y})^2+\sum_{i}(y-\hat{y})^2=\sum_{i}(y-\overline{y})^2$$<br>$$SSR+SSE=SST$$</p></blockquote><p>$R^2取值为[0,1]$，越接近1，拟合程度越好，$R^2=1$时表示回归方程可以完全解释因变量的变化；而如果$R^2$值过低，则说明自变量和因变量之间可能不存在<strong>线性关系</strong>。</p><h4 id="六、习题"><a href="#六、习题" class="headerlink" title="六、习题"></a>六、习题</h4><h5 id="1-缩放"><a href="#1-缩放" class="headerlink" title="1.缩放"></a>1.缩放</h5><blockquote><p>Suppose you want to predict a house’s price as a function of its size. </p><p>Your model is$h_\theta(x) = \theta_0 + \theta_1(\text{size}) + \theta_2\sqrt{(\text{size})}$.</p><p>Suppose size ranges from 1 to 1000 (feet^22). You will implement this by fitting a model</p><p>$h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2$.</p><p>Finally, suppose you want to use feature scaling (without mean normalization).Which of the following choices for $x_1$ and $x_2$ should you use? (Note: $\sqrt{1000} \approx 32$.)</p><p>A.$x_1 = \text{size},\ x_2 = 32\sqrt{(\text{size})}$</p><p>B.$x_1=32(\text{size}),\ x_2=\sqrt{(\text{size})}$</p><p>C.$x_1 = \frac{\text{size}}{1000},\ x_2 = \frac{\sqrt{(\text{size})}}{32}$</p><p>D.$x_1 = \frac{\text{size}}{32},\ x_2=\sqrt{(\text{size})}$</p><p>答案：C</p></blockquote><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/Java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/11/Java%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><p>菜鸟教程</p></li><li><p>《疯狂Java讲义》——李刚</p></li></ul><h4 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h4><h5 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1.类型转换"></a>1.类型转换</h5><ul><li><p>自动类型转换：</p><blockquote><p>byte——short——int——long——float——double</p><p>​                char ——|</p><p>1_bit        2_bit       4_bit    8_bit        4_bit       8_bit</p></blockquote><a id="more"></a><p><img src="https://user-images.githubusercontent.com/49241298/72427656-34148100-37c7-11ea-9163-2c610c6d5062.png"></p><p><img src="https://user-images.githubusercontent.com/49241298/72427679-4098d980-37c7-11ea-8509-c49ba6162756.png"></p><p><img src="https://user-images.githubusercontent.com/49241298/72427680-41317000-37c7-11ea-906a-f018dfb6014d.png"></p><p><img src="https://user-images.githubusercontent.com/49241298/72427681-41317000-37c7-11ea-8a29-5e53242e1f83.png"></p></li></ul><ul><li><p>强制类型转换</p><p><img src="https://user-images.githubusercontent.com/49241298/72427682-42629d00-37c7-11ea-9a28-ca8b69788426.png"></p></li></ul><ul><li>表达式类型自动提升<ul><li>char与其他类型变量运算时，自动转化为int类型再参与运算。</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/49241298/72427683-42fb3380-37c7-11ea-97a9-3417bd8c7fdc.png"></p><ul><li><p>总结：</p><ul><li>低类型可以自动转化为高类型。高类型除了int至char/short/byte，其他的都需要强制类型转换。</li></ul></li></ul><h5 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h5><ul><li><p>&amp;&amp;与&amp;</p><ul><li>&amp;&amp;当第一个条件不成立之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止</li></ul></li><li><p>在Java中%是取余运算符，要求两端操作数为整型（×）∵long，int，float，double都可以。</p></li><li><p>？：：</p><pre><code class="hljs java">expression?:s1:s2<span class="hljs-comment">//二者类型相同</span></code></pre></li></ul><h5 id="3-默认初始化"><a href="#3-默认初始化" class="headerlink" title="3.默认初始化"></a>3.默认初始化</h5><ul><li>基本数据类型的数组在创建之后，已经赋默认值 0 （或0L、0.0D、0.0F）；引用类型的数组在创建之后，已经赋默认值null(单不能使用)</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;<span class="hljs-keyword">static</span> String s;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String s2;<span class="hljs-comment">//System.out.println(s2); //不能用</span>System.out.println(s);<span class="hljs-comment">//类变量，加载时初始化了，null</span>&#125;&#125;String[] sa=<span class="hljs-keyword">new</span> String [<span class="hljs-number">3</span>];out.println(sa[<span class="hljs-number">0</span>]);<span class="hljs-comment">//null</span><span class="hljs-comment">//String[] sa=new String[] &#123;&#125;;</span><span class="hljs-comment">//out.println(sa[0]); //Error</span></code></pre><h5 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4.流程控制"></a>4.流程控制</h5><ul><li>switch中只能整型、short、byte、字符型char</li></ul><h5 id="5-基本类型"><a href="#5-基本类型" class="headerlink" title="5.基本类型"></a>5.基本类型</h5><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>序号</td><td>数据类型</td><td>字节</td><td>封装类</td><td>默认值</td><td>可表示数据范围</td></tr><tr><td>1</td><td>byte(位)</td><td>1</td><td>Byte</td><td>0</td><td>-128~127</td></tr><tr><td>2</td><td>short(短整数)</td><td>2</td><td>Short</td><td>0</td><td>-32768~32767</td></tr><tr><td>3</td><td>int(整数)</td><td>4</td><td>Integer</td><td>0</td><td>-2147483648~2147483647</td></tr><tr><td>4</td><td>long(长整数)</td><td>8</td><td>Long</td><td>0</td><td>-9223372036854775808~9223372036854775807</td></tr><tr><td>5</td><td>float(单精度)</td><td>4</td><td>Float</td><td>0.0</td><td>1.4E-45~3.4028235E38</td></tr><tr><td>6</td><td>double(双精度)</td><td>8</td><td>Double</td><td>0.0</td><td>4.9E-324~1.7976931348623157E308</td></tr><tr><td>7</td><td>char(字符)</td><td>2</td><td>Character</td><td>空</td><td>0~65535</td></tr><tr><td>8</td><td>boolean</td><td>1</td><td>Boolean</td><td>flase</td><td>true或false</td></tr></tbody></table><h4 id="二、类与对象"><a href="#二、类与对象" class="headerlink" title="二、类与对象"></a>二、类与对象</h4><h5 id="1-修饰符"><a href="#1-修饰符" class="headerlink" title="1.修饰符"></a>1.修饰符</h5><ol><li><p>访问修饰符</p><ul><li><p>简介：</p><blockquote><p><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p><p><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p><p><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法<br><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</p><p><img src="https://user-images.githubusercontent.com/49241298/72427667-3b3b8f00-37c7-11ea-8ac3-60c57743dba7.png" alt="7"></p></blockquote></li><li><p>default：</p></li><li><p>private：</p><ul><li>被声明为 <strong>private</strong> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明<strong>private</strong></li><li>private的方法<strong>不能被子类重写</strong>，因为private修饰的方法对子类是隐藏的，即子类无法访问该方法。</li></ul></li><li><p>protected：</p><ul><li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li><li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li><li>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</li><li>接口及接口的成员变量和成员方法不能声明为 protected,如图：<img src="https://www.runoob.com/wp-content/uploads/2013/12/java-protected.gif"></li></ul></li><li><p>public：</p><ul><li>接口里的变量都隐式声明为 <strong>public static final</strong> ,而接口里的方法默认情况下访问权限为 <strong>public</strong>。</li></ul></li></ul></li><li><p>非访问修饰符</p><ul><li><p>简介</p><blockquote><p>static 修饰符，用来修饰类方法、类变量。</p><p>final 修饰符，用来修饰类、方法、变量，<strong>final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</strong></p><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p></blockquote></li><li><p>final</p><ul><li>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</li><li>final 修饰符通常和 static 修饰符一起使用来创建类常量。</li><li>final方法<strong>可以被继承</strong>，<strong>不能被重写</strong></li></ul></li><li><p>abstract</p><ul><li><p>抽象类：</p><ul><li><p><strong>抽象类不能用来实例化对象</strong>，声明抽象类的唯一目的是为了将来对该类进行扩充。</p></li><li><p>一个<strong>类</strong>不能同时被 abstract 和 final 修饰（因为final类不能被继承，就不能在子类中实现，即重写）。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><ul><li>抽象类可以包含抽象方法和非抽象方法。</li></ul><ul><li><p>抽象方法：</p><ul><li><p>抽象方法是一种没有任何实现的方法，该方法的的具体<strong>实现由子类实现（即重写）</strong>。</p></li><li><p>抽象方法<strong>不能被声明成 final（不能继承所以不能重写） 和 static</strong>。（abstract和static可以同时修饰内部类）</p></li><li><p>任何继承抽象类的子类必须实现父类的<strong>所有抽象方法</strong>，<strong>除非该子类也是抽象类</strong>。</p></li><li><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类<strong>可以不包含</strong>抽象方法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//抽象方法</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span></span>&#123;    <span class="hljs-comment">//实现抽象方法</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span></span>&#123;        ......    &#125;&#125;</code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>synchronized</p><blockquote><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showDetails</span><span class="hljs-params">()</span></span>&#123;       &#125;</code></pre></blockquote></li></ul></li></ol><h5 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h5><ul><li><p>简介：</p><blockquote><p>消除臃肿。子类拥有父类<strong>非 private</strong> 的属性、方法。</p></blockquote></li><li><p>访问控制与继承：</p><ul><li>父类中声明为 public 的方法在子类中也必须为 public。</li><li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li><li>父类中声明为 private 的方法，不能够被继承。</li></ul></li><li><p>接口：</p><ul><li><p>使用 implements 关键字可以变相的使 Java 具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>,<span class="hljs-title">B</span> </span>&#123;&#125;</code></pre></li><li></li></ul></li><li><p>构造器</p><ul><li><p>子类是<strong>不继承父类的构造器</strong>（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p></li><li><p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会<strong>自动调用父类的无参构造器</strong>。</p></li><li><p>类可以只有有参构造器，而没有无参构造器。</p></li><li><p>父类没有无参构造器，且子类构造器中没有显示调用父类构造器时，报错。</p><p>创建子类对象时，先创建父类对象。如果没有super，则调用F()，因为没有，所以报错。</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;<span class="hljs-comment">//F()&#123;&#125;</span>F(<span class="hljs-keyword">int</span> i)&#123;<span class="hljs-keyword">this</span>.i=i;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span></span>&#123;    Test(<span class="hljs-keyword">int</span> i)&#123;<span class="hljs-comment">//Error，F() not defined  </span>    <span class="hljs-comment">//super(i);//换成super就可以了。</span>    <span class="hljs-keyword">this</span>.i=i;    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test t = <span class="hljs-keyword">new</span> Test(<span class="hljs-number">10</span>);    System.out.println(t.i);    &#125;&#125;</code></pre></li></ul></li></ul><ul><li><p>this与super：</p><ul><li>构造器不能像其他方法那样直接调用，只能结合new使用。因此<strong>在构造器中</strong>使用this调用构造器时，可以避免创建一个新对象，还可以降低耦合性。</li><li>在构造器中，如果使用this/super调用其他的构造器，则该代码应该写在<strong>第一行</strong>。</li><li>当子类构造器要给父类中 private 的变量赋值时，就可以<strong>直接使用super</strong>，而非调用赋值函数。</li><li></li></ul></li></ul><h5 id="3-重写"><a href="#3-重写" class="headerlink" title="3.重写"></a>3.重写</h5><ul><li><p>重写方法：</p><ul><li><strong>方法名</strong>相同、<strong>形参列表</strong>相同、子类中<strong>访问权限</strong>更大。</li></ul></li><li><p>父类的成员方法只能被它的子类重写。</p><ul><li><strong>返回类型</strong>与被重写方法的返回类型<strong>可以不相同</strong>，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，Java7 及更高版本可以不同）。</li><li>如果子类中重写了父类的方法，那子类的对象<strong>无法直接</strong>访问父类被覆盖的方法，而可以在子类的方法中调用该被覆盖的方法。</li><li>如果子类中定义了和父类同名的<strong>成员变量</strong>，并不是完全覆盖，只是隐藏，同样可以使用super调用。</li><li>如果父类构造器中调用了父类的一个方法，且该方法被子类重写了。当创建子类对象之前创建父类对象时，<strong>调用子类重写之后的方法</strong>。</li><li>如果<strong>不能继承</strong>一个方法，<strong>则不能重写</strong>这个方法。因此，private方法不能重写，构造器不能重写。</li><li>声明为 <strong>final</strong> 的方法不能被重写。</li><li>声明为 <strong>static</strong> 的方法不能被重写，但是能够被再次声明。</li></ul></li></ul><h4 id="三、类与对象的应用"><a href="#三、类与对象的应用" class="headerlink" title="三、类与对象的应用"></a>三、类与对象的应用</h4><h5 id="1-对象处理"><a href="#1-对象处理" class="headerlink" title="1.对象处理"></a>1.对象处理</h5><ul><li><p>==和equals</p><ul><li><p>如果两个<strong>基本</strong>的<strong>数值</strong>类型变量，（不论数据类型是否相同），只要值相等，就返回true。</p></li><li><p>如果两个引用型变量，只有指向同一对象时，==才返回true。</p></li><li><p>==<strong>不可</strong>用于比较类型上<strong>没有继承关系</strong>的两个对象。</p><pre><code class="hljs java">out.println(<span class="hljs-string">&quot;hello&quot;</span>==<span class="hljs-keyword">new</span> Test());<span class="hljs-comment">//因为String和Test没有继承关系，因此报错</span></code></pre></li><li><p><strong>Object(StringBuffer等许多类)默认提供的equals()只比较对象的地址，因此本质上和==一样。</strong>在实际应用中，常需要重写equals()。</p></li><li><p>重写equals()的要求：</p><ul><li>自反性：x.equals(x)为true</li><li>对称性：x.equals(y)为true，则y.euqals(x)也应为true</li><li>传递性：x.equals(y)为true，y.equals(z)为true，则x.equals(z)也应该为true</li><li>一致性：变量不变时，多少次返回结果应一致。</li><li>当x不为null时，应使x.equals(null)返回false。</li></ul></li></ul></li><li><p>常量池：</p><ul><li><p>常量池保证相同的字符串直接量只有一个，不会产生多个副本。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">aaa</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String s1=<span class="hljs-string">&quot;AstraStar&quot;</span>;String s2=<span class="hljs-string">&quot;Astra&quot;</span>;String s3=<span class="hljs-string">&quot;Star&quot;</span>;String s4=<span class="hljs-string">&quot;Astra&quot;</span>+<span class="hljs-string">&quot;Star&quot;</span>;<span class="hljs-comment">//编译时就确定,直接引用常量池中的AstraStar</span>String s5=s2+s3; <span class="hljs-comment">//编译时没确定,因此不引用常量池的AstraStar</span>String s6=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;AstraStar&quot;</span>);<span class="hljs-comment">//在堆内存，不引用常量池</span>out.println(<span class="hljs-string">&quot;s1:&quot;</span>+System.identityHashCode(s1)+<span class="hljs-string">&quot;\ns2:&quot;</span>+System.identityHashCode(s2)+<span class="hljs-string">&quot;\ns3:&quot;</span>+System.identityHashCode(s3)+<span class="hljs-string">&quot;\ns4:&quot;</span>+System.identityHashCode(s4)+<span class="hljs-string">&quot;\ns5:&quot;</span>+System.identityHashCode(s5)+<span class="hljs-string">&quot;\ns6:&quot;</span>+System.identityHashCode(s6));out.println((s1==s4)+<span class="hljs-string">&quot; &quot;</span>+(s1==s5)+<span class="hljs-string">&quot; &quot;</span>+(s4==s5)+<span class="hljs-string">&quot; &quot;</span>+(s1==s6));&#125;&#125;</code></pre><p><img src="https://user-images.githubusercontent.com/49241298/72427669-3c6cbc00-37c7-11ea-9060-d19c3f9b70a5.png"></p></li></ul></li></ul><h5 id="2-final修饰符"><a href="#2-final修饰符" class="headerlink" title="2.final修饰符"></a>2.final修饰符</h5><ul><li><p>final成员变量</p><ul><li>final修饰的成员变量必须<strong>显示地初始化</strong>。</li></ul></li><li><p>final基本类型变量与final引用类型变量</p><ul><li>对于final修饰的引用类型变量，只能使引用的<strong>地址</strong>不被更改，对象完全可以改变。</li></ul></li><li><p>宏替换</p><ul><li><p>上文常量池中，我们发现s5=s2+s3不能在编译时确定内容，因此没引用常量池中的s1。而将s2和s3分别用final修饰，则可以使其地址一样：</p><pre><code class="hljs java">String str1=<span class="hljs-string">&quot;AB&quot;</span>;<span class="hljs-keyword">final</span> String str2=<span class="hljs-string">&quot;A&quot;</span>;<span class="hljs-keyword">final</span> String str3=<span class="hljs-string">&quot;B&quot;</span>;String str4=str2+str3;out.println(str1==str4);<span class="hljs-comment">//结果为true</span></code></pre></li></ul></li><li><p>final方法</p><ul><li>可以继承，可以重载，<strong>不可以重写</strong></li></ul></li><li><p>final类</p><ul><li>不能继承</li></ul></li></ul><h5 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h5><ul><li><p>抽象方法</p><ul><li><p>抽象方法与空方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;;<span class="hljs-comment">//抽象方法必须属于抽象类</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;</code></pre></li></ul></li></ul><h5 id="4-接口"><a href="#4-接口" class="headerlink" title="4.接口"></a>4.接口</h5><ul><li><p><del><strong>接口中全是抽象方法</strong></del>，<em>JDK 1.8 以后，接口里可以有静态方法和方法体了。</em></p></li><li><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名；接口的字节码文件保存在 .class 结尾的文件中。</p></li><li><p>接口可以有多个直接父接口，但接口只能继承接口，不能继承类；</p></li><li><p>接口里定义的是多个类共同的公共行为规范，因此<strong>所有成员都为public访问权限</strong>；</p></li><li><p>接口中可以包含的成员：</p><ul><li><p>变量：</p><ul><li><p>接口中的成员变量<strong>只</strong>能是<strong>静态常量</strong>。在接口里声明的成员变量，会自动加上<strong>public static final</strong>，如下，二行代码结果完全一样：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> a=<span class="hljs-number">5</span>;<span class="hljs-comment">//public与final因为共同规范；static因为接口不能实例化，所以static。</span></code></pre></li></ul></li><li><p>方法：</p><ul><li><p>抽象方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//public abstract</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;</code></pre></li><li><p>类方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//public static。不能加default</span>    out.println(<span class="hljs-string">&quot; &quot;</span>);&#125;</code></pre></li><li><p>默认方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-title">l</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//default。不能加static，因此只能用接口的实现类的实例调用</span>    out.println(<span class="hljs-string">&quot; &quot;</span>);&#125;</code></pre></li></ul></li><li><p>内部类：</p><ul><li>内部接口</li><li>枚举</li></ul></li></ul></li><li><p>一个类实现一个/多个接口之后，必须<strong>重写</strong>这些接口里的<strong>所有抽象</strong>方法。否则该类也必须定义为抽象类。</p></li><li><p>接口与抽象类：</p><ul><li>都不可被实例化，都可以包含抽象方法</li><li><strong>抽象类可以包含普通方法，而接口不能</strong></li><li><strong>抽象类可以定义普通成员变量，而接口不能</strong></li><li>接口不包含构造器，而抽象类可以（<strong>不用于创建对象，而是让子类调用，实现抽象类的初始化</strong>）</li><li>接口不包含初始化块，而抽象类可以。</li><li>一个类只能继承一个类，而一个类可以实现多个接口。</li></ul></li><li><p>接口的使用：</p><ul><li><p>接口的继承：<del>获得父接口的所有抽象方法、常量</del></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifA</span></span>&#123;    <span class="hljs-keyword">int</span> A=<span class="hljs-number">5</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testA</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifB</span></span>&#123;    <span class="hljs-keyword">int</span> B=<span class="hljs-number">5</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testB</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ifA</span>,<span class="hljs-title">ifB</span></span>&#123;    <span class="hljs-keyword">int</span> C=<span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        System.out.println(ifC.C);    &#125;&#125;</code></pre></li><li><p>类实现</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ifA</span></span>&#123;<span class="hljs-keyword">int</span> a=<span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ifA</span></span>&#123;<span class="hljs-comment">//static int geta() &#123; //static method cannot hide geta() from ifA</span><span class="hljs-comment">//int geta() &#123; //cannot reduce the visibility of geta() from ifA</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> ifA.a;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Test t=<span class="hljs-keyword">new</span> Test();ifA ifa=<span class="hljs-keyword">new</span> Test();out.println(t.geta());out.println(ifa.geta());&#125;&#125;</code></pre></li></ul></li></ul><h5 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h5><ul><li><p>内部类提供了更好的封装，可以吧内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</p></li><li><p>内部类和外部类</p><ul><li>内部类可以多使用三个修饰符：<strong>private、protected、static</strong></li><li>非静态内部类不能拥有静态成员，即<strong>静态成员</strong>只能出现在<strong>静态内部类</strong>中。</li></ul></li><li><p>非静态内部类</p><ul><li><p><strong>非静态内部类里可以直接访问外部类的private的成员，而外部类不能直接访问内部类的变量。</strong></p></li><li><p>同名变量：</p><pre><code class="hljs java">OuterClass.<span class="hljs-keyword">this</span>.str<span class="hljs-comment">//外部类变量</span>InnerClass.<span class="hljs-keyword">this</span>.str<span class="hljs-comment">//内部类变量，或this.str</span></code></pre></li><li><p>非静态内部类<strong>不</strong>能有<strong>静态成员变量</strong>，<strong>静态方法</strong>，<strong>静态初始化块</strong>。外部类的静态成员不能访问非静态内部类。</p></li></ul></li><li><p>静态内部类</p><ul><li>static的作用是将类的成员变为<strong>类相关</strong>，而非实例相关。因此外部类不能用static修饰，而内部类可以。</li></ul></li><li><p>(非)静态内部类案例：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cow</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> w;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i1=<span class="hljs-number">2019</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i2=<span class="hljs-number">2020</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> w)</span> </span>&#123;<span class="hljs-comment">//2</span><span class="hljs-keyword">this</span>.w=w;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CowLeg</span></span>&#123;<span class="hljs-comment">//非静态内部类</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> l;<span class="hljs-comment">//private static double h;//非静态内部类不能有静态成员变量</span><span class="hljs-comment">//public static void train() &#123;&#125;//非静态内部类不能有静态方法</span><span class="hljs-comment">//static &#123;out.print(&quot;a&quot;);&#125;//非静态内部类不能有静态代码块</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CowLeg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> l)</span> </span>&#123;<span class="hljs-comment">//4</span><span class="hljs-keyword">this</span>.l=l;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//5</span>out.println(w+<span class="hljs-string">&quot; &quot;</span>+l);<span class="hljs-comment">//非静态内部类的方法可以直接访问外部类的private成员</span>out.println(Cow.<span class="hljs-keyword">this</span>.i1);<span class="hljs-comment">//如果外内部类有同名变量，可以用Outer.this访问</span>out.println(<span class="hljs-keyword">this</span>.l);<span class="hljs-comment">//等价于out.println(CowLeg.this.l);</span><span class="hljs-comment">//out.println(Cow.this.i2);//非静态可以访问静态，但不推荐</span>&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticClass</span></span>&#123;<span class="hljs-comment">//静态内部类</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i3=<span class="hljs-number">2021</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i4=<span class="hljs-number">2022</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">info_s</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//out.pritnln(w);//静态内部类的方法不能访问外部类的非静态成员</span>out.println(i2);<span class="hljs-comment">//静态内部类的方法可以访问外部类的静态成员</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//3</span>        out.println(<span class="hljs-keyword">new</span> CowLeg(<span class="hljs-number">1.2</span>).l);<span class="hljs-comment">//外部类中，可以用new显式创建对象来访问内部类成员</span>        CowLeg cl=<span class="hljs-keyword">new</span> CowLeg(<span class="hljs-number">1.1</span>);<span class="hljs-comment">//外部类的非静态方法可以访问非静态内部类</span>cl.info();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test_s</span><span class="hljs-params">()</span> </span>&#123;out.println(StaticClass.i4);<span class="hljs-comment">//外部类用静态内部类的类名访问其类成员</span><span class="hljs-comment">//out.println(StaticClass.i3);  //外部类的方法不能用静态内部类的类名访问其非静态成员↓</span>out.println(<span class="hljs-keyword">new</span> StaticClass().i3);<span class="hljs-comment">//但可以用实例来访问</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//1</span><span class="hljs-comment">//CowLeg cl2=new CowLeg(1.2);//外部类的静态方法不能访问非静态内部类</span>Cow cow=<span class="hljs-keyword">new</span> Cow(<span class="hljs-number">370</span>);cow.test();&#125;&#125;</code></pre><ul><li><p>逻辑图</p><p><img src="https://user-images.githubusercontent.com/49241298/72427672-3e367f80-37c7-11ea-996d-91d176b5cbe4.png"></p></li></ul></li><li><p>内部类的应用</p><ul><li><p>创建静态内部类对象时，不用创建外部类对象。</p></li><li><p>在外部类以外的地方创建静态内部类对象的语句：</p><pre><code class="hljs java">OutClass.InnerClass oi=<span class="hljs-keyword">new</span> OuterClass.InnerClass();</code></pre></li></ul></li><li><p>局部内部类？匿名内部类？</p></li></ul><h5 id="6-修饰符总结"><a href="#6-修饰符总结" class="headerlink" title="6.修饰符总结"></a>6.修饰符总结</h5><table><thead><tr><th></th><th>外部类/接口</th><th>成员变量</th><th>方法</th><th>构造器</th><th>初始化块</th><th>内部类</th><th>局部成员</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td></td></tr><tr><td>protected</td><td></td><td>√</td><td>√</td><td><strong>√</strong></td><td></td><td>√</td><td></td></tr><tr><td>包访问控制符</td><td>√</td><td>√</td><td>√</td><td><strong>√</strong></td><td>o</td><td>√</td><td>o</td></tr><tr><td>private</td><td></td><td>√</td><td>√</td><td><strong>√</strong></td><td></td><td>√</td><td></td></tr><tr><td>abstract</td><td>√</td><td></td><td>√</td><td></td><td></td><td><strong>√</strong></td><td></td></tr><tr><td>final</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td><strong>√</strong></td><td>√</td></tr><tr><td>static</td><td>√</td><td>√</td><td>√</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>synchronized</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td></td></tr><tr><td>default</td><td></td><td></td><td><strong>√</strong></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><img src="https://user-images.githubusercontent.com/49241298/72427674-3ecf1600-37c7-11ea-9150-aedf2ad4d176.png" alt="11"></li><li>synchronized也可以修饰代码块</li></ul><h4 id="四、Java集合"><a href="#四、Java集合" class="headerlink" title="四、Java集合"></a>四、Java集合</h4><h5 id="1-Array"><a href="#1-Array" class="headerlink" title="1. Array"></a>1. Array</h5><ul><li><p>一维</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 静态初始化：只能指定数组元素的初始值，不能指定长度</span>    <span class="hljs-keyword">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;    <span class="hljs-keyword">int</span>[] arr2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<span class="hljs-comment">// 简化写法</span>    <span class="hljs-keyword">int</span>[] arr3 = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;    <span class="hljs-keyword">int</span>[] arr4 = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;    <span class="hljs-comment">// Arrays类函数</span>    out.println(<span class="hljs-string">&quot;arr1.equals(arr2): &quot;</span> + Arrays.equals(arr1, arr2));    out.println(<span class="hljs-string">&quot;arr1 == arr2: &quot;</span>+(arr1==arr4));    out.println(<span class="hljs-string">&quot;arr1.equals(arr3): &quot;</span> + Arrays.equals(arr1, arr3));    out.println(<span class="hljs-string">&quot;arr1 == arr3: &quot;</span>+(arr1==arr3));    out.println(<span class="hljs-string">&quot;arr3.equals(arr4): &quot;</span> + Arrays.equals(arr3, arr4));    out.println(<span class="hljs-string">&quot;arr3 == arr4: &quot;</span>+(arr3==arr4));<span class="hljs-comment">//new省略了，所以实际上创建了另一个对象</span>    <span class="hljs-comment">//输出数组</span>    out.println(<span class="hljs-string">&quot;arr1:&quot;</span> + Arrays.toString(arr1)+<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-comment">// 动态初始化：只能指定长度，系统根据类型不同设置不同的初始值</span>    <span class="hljs-keyword">int</span>[] a1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// byte、short、int、long初始值为0</span>    <span class="hljs-keyword">float</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// float、double初始值为0.0</span>    <span class="hljs-keyword">char</span>[] a3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始值为&#x27;\u0000&#x27;</span>    <span class="hljs-keyword">boolean</span>[] a4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">// 初始值为false</span>    out.println(<span class="hljs-string">&quot;a1[0]:&quot;</span> + a1[<span class="hljs-number">0</span>]);    out.println(<span class="hljs-string">&quot;a2[0]:&quot;</span> + a2[<span class="hljs-number">0</span>]);    out.println(<span class="hljs-string">&quot;a3[0]:&quot;</span> + a3[<span class="hljs-number">0</span>]);<span class="hljs-comment">//显示为空</span>    out.println(<span class="hljs-string">&quot;a3[0] == &#x27;\u0000&#x27;:&quot;</span>+(a3[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\u0000&#x27;</span>));    out.println(<span class="hljs-string">&quot;a4[0]:&quot;</span> + a4[<span class="hljs-number">0</span>]);&#125;</code></pre></li><li><p>二维</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">//block1</span>    <span class="hljs-keyword">int</span> [][]a;    a=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>][];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,len=a.length;i&lt;len;i++) &#123;        out.println(a[i]);    &#125;    a[<span class="hljs-number">0</span>]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];    a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,len=a[<span class="hljs-number">0</span>].length;i&lt;len;i++) &#123;        out.println(a[<span class="hljs-number">0</span>][i]);    &#125;    Arrays.sort(a[<span class="hljs-number">0</span>]);    out.println(Arrays.toString(a[<span class="hljs-number">0</span>]));    <span class="hljs-comment">//block2</span>    String[][] str1= &#123;        <span class="hljs-comment">//3, 会报错：cannot convert from int to String[]</span>        <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>],        <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;    &#125;;    <span class="hljs-keyword">int</span> [][] arr= &#123;        <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,        <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">2</span>]    &#125;;&#125;</code></pre></li></ul><h4 id="五、异常处理"><a href="#五、异常处理" class="headerlink" title="五、异常处理"></a>五、异常处理</h4><ul><li><p>try块与if不同，try后面的{}不能省略，即使只有一行代码。catch也不能省略。</p></li><li><p>try里声明的变量是代码块内的局部变量，catch不能访问。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myException</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">int</span> a=Integer.parseInt(args[<span class="hljs-number">0</span>]);<span class="hljs-keyword">int</span> b=Integer.parseInt(args[<span class="hljs-number">1</span>]);<span class="hljs-keyword">int</span> c=a/b;out.println(<span class="hljs-string">&quot;c:&quot;</span>+c);&#125;<span class="hljs-comment">//catch (RuntimeException re)&#123;&#125; //后面会unreachable，应该先小后大</span><span class="hljs-keyword">catch</span>(IndexOutOfBoundsException ie) &#123;out.println(<span class="hljs-string">&quot;数组越界，输入的参数不够&quot;</span>);&#125;<span class="hljs-comment">//catch(IndexOutOfBoundsException ie) &#123;// already handled by last</span><span class="hljs-comment">//java7之后一个catch可以捕获多种异常</span><span class="hljs-keyword">catch</span> (NumberFormatException|ArithmeticException ne) &#123;out.println(<span class="hljs-string">&quot;数字格式异常/算术异常&quot;</span>);<span class="hljs-comment">//捕获多异常时，异常变量默认有final修饰，因此下列错误：</span><span class="hljs-comment">//ne =new ArithmeticException(&quot;test&quot;);</span>&#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;out.println(<span class="hljs-string">&quot;未知异常&quot;</span>);<span class="hljs-comment">//捕获一种异常时，final修饰</span>e=<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;test&quot;</span>);&#125;<span class="hljs-comment">//不管try是否异常、执行了哪一个catch、甚至try/catch里执行了return，finally总会执行</span><span class="hljs-keyword">finally</span> &#123;out.println(<span class="hljs-string">&quot;finally总是被执行&quot;</span>);<span class="hljs-comment">//不要在finally里使用return/throw这些强制终止方法的语句;</span>&#125;&#125;&#125;</code></pre></li><li><p>throws</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myThrows</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;test();<span class="hljs-comment">//因为test声明跑出IO异常，因此调用test的方法要么在try-catch中，</span><span class="hljs-comment">//要么在另一个声明throws的方法中</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<span class="hljs-comment">//FIS的构造器声明抛出IO异常，因此调用FIS的代码在try-catch或throws中</span>FileInputStream fis=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;a.txt&quot;</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">myThrows</span></span>&#123;<span class="hljs-comment">//public void test() throws Exception&#123;&#125;//子类不能声明比父类更大的异常</span>&#125;</code></pre></li></ul><ul><li><p>throw</p></li><li><p>catch+throw</p></li></ul><h4 id="六、Swing"><a href="#六、Swing" class="headerlink" title="六、Swing"></a>六、Swing</h4><ul><li><p><img src="https://user-images.githubusercontent.com/49241298/72427675-3f67ac80-37c7-11ea-9657-30cb5f39a94c.png" alt="12"></p><pre><code class="hljs java"><span class="hljs-comment">//Component类提供了几个常用方法，见P_383</span>setLocation(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y);setSize(<span class="hljs-keyword">int</span> width,<span class="hljs-keyword">int</span> height);setBounds(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> w,<span class="hljs-keyword">int</span> h);setVisvle(Boolean b);<span class="hljs-function">Component <span class="hljs-title">add</span><span class="hljs-params">(Component comp)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getComponentCount</span><span class="hljs-params">()</span></span>;Component[] getComponents();</code></pre></li></ul><ul><li><p>\1.     Applet是一种特殊的Panel，它是Java Applet程序的最外层容器。</p></li><li><p>\1.     panel（含applet）的默认布局是流式布局，window（frame和dialog）是边界布局</p></li><li><p>\1.     java Applet 程序必须在浏览器中执行</p></li><li></li></ul><h5 id="1-ActionListener"><a href="#1-ActionListener" class="headerlink" title="1. ActionListener:"></a>1. ActionListener:</h5><pre><code class="hljs java"><span class="hljs-keyword">final</span> String COMMAND_OK = <span class="hljs-string">&quot;OK&quot;</span>;<span class="hljs-keyword">final</span> String COMMAND_CANCEL = <span class="hljs-string">&quot;Cancel&quot;</span>;JButton okBtn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;OK&quot;</span>);okBtn.setActionCommand(COMMAND_OK);             <span class="hljs-comment">// 按钮绑定动作命令</span>JButton cancelBtn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;Cancel&quot;</span>);cancelBtn.setActionCommand(COMMAND_CANCEL);     <span class="hljs-comment">// 按钮绑定动作命令</span><span class="hljs-comment">// 创建一个动作监听器实例</span>ActionListener listener = <span class="hljs-keyword">new</span> ActionListener() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;        <span class="hljs-comment">// 获取事件源，即触发事件的组件（按钮）本身</span>        <span class="hljs-comment">// e.getSource();</span>            <span class="hljs-comment">// 获取动作命令</span>        String command = e.getActionCommand();                <span class="hljs-comment">// 根据动作命令区分被点击的按钮</span>        <span class="hljs-keyword">if</span> (COMMAND_OK.equals(command)) &#123;            System.out.println(<span class="hljs-string">&quot;OK 按钮被点击&quot;</span>);                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (COMMAND_CANCEL.equals(command)) &#123;            System.out.println(<span class="hljs-string">&quot;Cancel 按钮被点击&quot;</span>);        &#125;    &#125;&#125;;<span class="hljs-comment">// 设置两个按钮的动作监听器（使用同一个监听器实例）</span>okBtn.addActionListener(listener);cancelBtn.addActionListener(listener);</code></pre><h5 id="2-JButton"><a href="#2-JButton" class="headerlink" title="2. JButton"></a>2. JButton</h5><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.swing.*;<span class="hljs-keyword">import</span> java.awt.event.ActionEvent;<span class="hljs-keyword">import</span> java.awt.event.ActionListener;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        JFrame jf = <span class="hljs-keyword">new</span> JFrame(<span class="hljs-string">&quot;测试窗口&quot;</span>);        jf.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);        jf.setLocationRelativeTo(<span class="hljs-keyword">null</span>);        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        JPanel panel = <span class="hljs-keyword">new</span> JPanel();        <span class="hljs-comment">// 创建一个按钮</span>        <span class="hljs-keyword">final</span> JButton btn = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">&quot;测试按钮&quot;</span>);        <span class="hljs-comment">// 添加按钮的点击事件监听器</span>        btn.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;                <span class="hljs-comment">// 获取到的事件源就是按钮本身</span>                <span class="hljs-comment">// JButton btn = (JButton) e.getSource();</span>                System.out.println(<span class="hljs-string">&quot;按钮被点击&quot;</span>);            &#125;        &#125;);        panel.add(btn);        jf.setContentPane(panel);        jf.setVisible(<span class="hljs-keyword">true</span>);    &#125;&#125;</code></pre><h4 id="七、多线程"><a href="#七、多线程" class="headerlink" title="七、多线程"></a>七、多线程</h4><ul><li><p>创建线程类</p><ul><li><p>继承Thread类：多个线程不能共享线程类的实例变量</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(;i&lt;<span class="hljs-number">10</span>;i++) &#123;System.out.println(getName()+<span class="hljs-string">&quot; &quot;</span>+i);<span class="hljs-comment">//System.out.println(this.getName()+&quot;&quot;+i);</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) &#123;System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; &quot;</span>+i);<span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>) &#123;<span class="hljs-keyword">new</span> FirstThread().start();<span class="hljs-keyword">new</span> FirstThread().start();&#125;&#125;&#125;&#125;</code></pre><p><img src="https://user-images.githubusercontent.com/49241298/72427676-4098d980-37c7-11ea-8593-557851f20737.png" alt="13"></p></li></ul></li></ul><ul><li>继承Runnable类</li></ul><ul><li><p>线程的生命周期</p><p>新状态：线程已被创建但尚未执行（）。</p><p>可执行状态(就绪)：线程可以执行，虽然不一定正在执行。CPU 时间随时可能被分配给该线程，从而使得它执行(调用start方法后)</p><p>死亡状态：正常情况下 run() 返回使得线程死亡。调用 stop()或 destroy() 亦有同样效果，但是不被推荐，前者会产生异常，后者是强制终止，不会释放锁。</p><p>阻塞状态：线程不会被分配 CPU 时间，无法执行。</p><p>运行状态 获得调度，执行线程的run方法</p></li><li><p>启动线程应该用start，而非run；</p></li><li><p>线程死亡</p><ul><li>线程结束后就处于死亡状态，结束方式：<ul><li>run()或call()执行完成，线程正常结束</li><li>线程抛出未捕获的异常/Error</li><li>调用线程的stop()</li></ul></li></ul></li><li><p>控制线程</p><ul><li>join</li><li>后台</li><li>sleep</li><li>让步yield</li></ul></li></ul><h4 id="八、输入输出"><a href="#八、输入输出" class="headerlink" title="八、输入输出"></a>八、输入输出</h4><h4 id="九、JDBC"><a href="#九、JDBC" class="headerlink" title="九、JDBC"></a>九、JDBC</h4><ul><li>JDBC是java 数据库连接API，它能完成3 件事，即与一个数据库建立连接、向数据库发送SQL 语句、处理数据库返回的结果。</li></ul><h4 id="N-1"><a href="#N-1" class="headerlink" title="N+1"></a>N+1</h4><ul><li><p>Java 具有简单、面向对象、稳定、与平台无关、解释型、多线程、动态等特点。</p></li><li><p>jdb.exe是Java调试器，如果编译器返回程序代码的错误，可以用它对程序进行调试；java.exe运行Java程序；javac.exe编译Java程序</p><pre><code class="hljs java">javac Hello.javajava Hello</code></pre></li></ul><ul><li><p>序列化</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><span class="hljs-class"></span>&#123;   <span class="hljs-keyword">public</span> String name;   <span class="hljs-keyword">public</span> String address;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> SSN;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> number;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mailCheck</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;      System.out.println(<span class="hljs-string">&quot;Mailing a check to &quot;</span> + name                           + <span class="hljs-string">&quot; &quot;</span> + address);   &#125;&#125;<span class="hljs-comment">//请注意，一个类的对象要想序列化成功，必须满足两个条件：</span><span class="hljs-comment">//该类必须实现 java.io.Serializable 接口。</span><span class="hljs-comment">//该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</span></code></pre></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/10/11/hexo%E4%B8%BB%E9%A2%98fluid%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/10/11/hexo%E4%B8%BB%E9%A2%98fluid%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用感受</p><ul><li>不支持pandoc</li></ul></blockquote><h4 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.    预处理"></a>1.    预处理</h4><h5 id="1-1-公式渲染问题"><a href="#1-1-公式渲染问题" class="headerlink" title="1.1 公式渲染问题"></a>1.1 公式渲染问题</h5><ul><li><p>问题描述：</p><p>安装pandoc之后，更换为fluid主题之后==hexo -g==的时候报错：</p></li></ul><pre><code class="hljs yaml">[<span class="hljs-string">ERROR</span>][<span class="hljs-string">hexo-renderer-pandoc</span>] <span class="hljs-attr">pandoc exited with code 9: pandoc: Unknown extension:</span> <span class="hljs-string">smart</span></code></pre><ul><li><p>解决办法：</p><p>参照<a href="https://github.com/wzpan/hexo-renderer-pandoc/pull/22">GitHub_issue：Fix pandoc &gt;=2.0 syntax</a>：</p><ul><li><p>先将Pandoc升级至2.0以上。如用pip：</p><pre><code class="hljs bash">pip install -upgrade pandoc==2.0a.1</code></pre></li><li><p>用git升级hexo-renderer-pandoc：</p><pre><code class="hljs bash">npm install --save hexo-renderer-pandoc@0.2.3</code></pre></li></ul></li></ul><p>刚才<code>2020年10月10日17:37:19</code>发现有的文章都没有渲染，看来还要搞一下。</p><ul><li>更新：<ul><li>其实大部分文章都渲染了。有一两篇文章没有渲染，应该是文章的问题。</li><li>把mathjax包卸载了，只剩pandoc了。用的katex。那一两篇有问题的还是不行，<code>有时间看看源码</code>。</li><li>另外，目前fluid是不渲染首页摘要中的公式，具体看这里<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/351">首页摘要中没有渲染LaTeX 数学公式</a>，但奇怪的是，有时候本地首页摘要也能渲染。</li></ul></li></ul><h4 id="2-主题配置"><a href="#2-主题配置" class="headerlink" title="2.    主题配置"></a>2.    主题配置</h4><h5 id="2-1-代码块重复"><a href="#2-1-代码块重复" class="headerlink" title="2.1    代码块重复"></a>2.1    代码块重复</h5><ul><li><p>问题描述：</p><p>如下所示，在原文中的一行代码被重复渲染两次：</p><p><img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/image-20201010180337211.png"></p></li><li><p>解决办法：</p><p>文件<code>_config.yml</code>中的代码和文件<code>fluid_config.yml</code>中的代码重复了。将其中一个改为false即可。<br>但因为我环境的原因，我将前者改为false，后者改为true。否则line number隐藏不了。</p></li></ul><p><code>_config.yml</code>中的代码：</p><pre><code class="hljs yaml"><span class="hljs-attr">highlight:</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><span class="hljs-comment">#第一处</span><span class="hljs-attr">prism_plugin:</span>  <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;preprocess&#x27;</span>     <span class="hljs-attr">theme:</span> <span class="hljs-string">&#x27;xonokai&#x27;</span>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">false</span></code></pre><p>确保</p><p><code>fluid_config.yml</code>中的代码：</p><pre><code class="hljs yaml"><span class="hljs-attr">code:</span>    <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">highlight:</span>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><span class="hljs-comment">#因为_config.yml里已经为true了，所以这里设置为false</span>  <span class="hljs-attr">lib:</span> <span class="hljs-string">&#x27;highlightjs&#x27;</span>    <span class="hljs-attr">highlightjs:</span>    <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;Github Gist&#x27;</span>      <span class="hljs-attr">bg_color:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">prismjs:</span>    <span class="hljs-attr">style:</span> <span class="hljs-string">&#x27;default&#x27;</span>     <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span></code></pre><p>  <img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201010223147.png" alt="图2"></p><h5 id="2-2-段落Tab缩进被吞了"><a href="#2-2-段落Tab缩进被吞了" class="headerlink" title="2.2    段落Tab缩进被吞了"></a>2.2    段落Tab缩进被吞了</h5><ul><li><p>问题描述：</p><p>在Typora中位于段首的Tab缩进上传后被吞了。如图所示：</p><p><u>Typora中显示</u>：<img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/indent1.png">，<u>fluid中显示</u>：<img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201010205523.png">，</p></li><li><p>解决办法：</p></li></ul><h5 id="2-3-文字高亮"><a href="#2-3-文字高亮" class="headerlink" title="2.3    文字高亮"></a>2.3    文字高亮</h5><ul><li>Typora中用<code>==文字==</code>实现黄色高亮，但fluid不支持这样的渲染，只支持``渲染。.</li></ul><h5 id="2-4-代码渲染错误"><a href="#2-4-代码渲染错误" class="headerlink" title="2.4    代码渲染错误"></a>2.4    代码渲染错误</h5><ul><li><p>问题描述：</p><p>某些情况下，插入的代码会被误认为是高亮文本。如图：</p><p>Typora中：<img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201011133130.png"></p><p>网站中：<img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201011133200.png"></p></li><li><p>解决办法：</p><p>破解了，和<strong>前面2.2</strong>一样，是因为fluid不识别tab的空格。所以把有空格缩进后的代码当做高亮文本了。</p><p>所以，还是尽量避免Typora的空格缩进吧。只用小标题。</p></li></ul><h5 id="2-5-代码缩进问题"><a href="#2-5-代码缩进问题" class="headerlink" title="2.5.    代码缩进问题"></a>2.5.    代码缩进问题</h5><ul><li><p>空格缩进，Tab缩进，零长度空格</p><ul><li>在WYSIWYG模式下，用Tab了，就不能插入代码块。</li><li>用空格缩进后写代码块，fluid会压缩缩进的长度。</li></ul></li><li><p>会压缩缩进长度：不论Typora中是用什么模式写的，不管是否断点是否Tab或空格。<strong>所以写代码，尽量别缩进</strong>。</p></li></ul><h5 id="2-6-换行问题"><a href="#2-6-换行问题" class="headerlink" title="2.6     换行问题"></a>2.6     换行问题</h5><p>是否有空行：有空行和无空行在WYSIWYG模式下一样，但在源码模式下不同：</p><ul><li><p>无空行</p><p><img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201011143041.png"></p></li><li><p>有空行</p><p><img src="https://blogjallery.oss-cn-beijing.aliyuncs.com/img/20201011143454.png"></p></li><li><p>小结：</p><ul><li>不同块之间尽量通过空行分开。（WYSIWYG模式下，Typora会自动在不同块之间加入<strong>源码模式下的空行</strong>[WYSIWYG模式下能看到但不能编辑，只能在源码模式下编辑]）</li><li>不换行的问题：在Next<a href="https://github.com/iissnan/hexo-theme-next/issues/1672"></a>.</li></ul></li></ul><h5 id="2-7-代码风格不能修改"><a href="#2-7-代码风格不能修改" class="headerlink" title="2.7 代码风格不能修改"></a>2.7 代码风格不能修改</h5><h4 id="3-图床管理工具"><a href="#3-图床管理工具" class="headerlink" title="3.    图床管理工具"></a>3.    图床管理工具</h4><h5 id="2-1-阿里云OSS上传失败"><a href="#2-1-阿里云OSS上传失败" class="headerlink" title="2.1    阿里云OSS上传失败"></a>2.1    阿里云OSS上传失败</h5><ul><li><p>问题描述：</p><p>按要求设置阿里云OSS，但上传失败。报错信息如下：</p><blockquote><p>2020-10-10 20:31:45 [PicGo INFO] Before transform<br>2020-10-10 20:31:45 [PicGo INFO] Transforming…<br>2020-10-10 20:31:46 [PicGo INFO] Before upload<br>2020-10-10 20:31:47 [PicGo INFO] Uploading…<br>2020-10-10 20:31:48 [PicGo WARN] failed<br>2020-10-10 20:31:48 [PicGo ERROR] StatusCodeError: 403 - “</p></blockquote></li><li><p>解决办法：</p><p>使用Picgo访问阿里云OSS，只能用子用户。所以创建一个子用户，然后重新配置Picgo就可以了。</p><ul><li>的</li><li>打的费撒发送端发送的发送到</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DecisionTree</title>
    <link href="/2019/11/24/DecisionTree/"/>
    <url>/2019/11/24/DecisionTree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：</p><ul><li><a href="https://juejin.im/post/5d2051dae51d454fbe24a6f7">https://juejin.im/post/5d2051dae51d454fbe24a6f7</a></li><li>李航-《统计学习方法》</li></ul></blockquote><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.    简介"></a>1.    简介</h4><p><code>blablabla........</code>此文中忽略结点和节点的区别，，，</p><h4 id="2-分支结束条件"><a href="#2-分支结束条件" class="headerlink" title="2.分支结束条件."></a><font color='red'>2.分支结束条件</font>.</h4><ul><li>当前结点包含的样本全属于同一类别，无需划分；例如：样本当中都是决定去相亲的，属于同一类别，就是不管特征如何改变都不会影响结果，这种就不需要划分了。</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分；例如：所有的样本特征都是一样的，就造成无法划分了，训练集太单一。</li><li>当前结点包含的样本集合为空，不能划分。</li></ul><!--more--><h4 id="3-树的成长过程"><a href="#3-树的成长过程" class="headerlink" title="3.树的成长过程.."></a><font color='red'>3.树的成长过程.</font>.</h4><ul><li>信息熵(简称熵，Entropy)越低，纯度越高。</li><li><code>信息熵</code>：<br>$$Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k$$<br>其中，D为<code>此分支的样本集合</code>；$|y|$为<code>标签列Y的类别数</code>；$p_k$为样本集合D中<code>属于k类别</code>的<code>样本占比</code>。<blockquote><p>可以证明，当$p_1=p_2=…=p_{|y|}$时，熵最大，即<code>不确定性最大</code>。</p></blockquote></li><li>信息增益：<br>$$<br>\begin{aligned}<br>Gain(D,A)&amp;=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)\<pre><code>&amp;=Ent(D)-\sum_&#123;v=1&#125;^&#123;V&#125;\frac&#123;|D^v|&#125;&#123;|D|&#125;(-\sum_&#123;k=1&#125;^&#123;|y|&#125;\frac&#123;|D^v_k|&#125;&#123;D^v&#125;log_2\frac&#123;|D^v_k|&#125;&#123;D^v&#125;)</code></pre>\end{aligned}<br>$$<br>其中，$|D^v|$为<code>第v个分支</code>的样本集合的<code>样本数</code>，$A$为分枝所用的<code>特征</code>；<br>公式的含义为：<strong>划分前的信息熵-划分后的信息熵</strong>。</li></ul><h4 id="4-决策树的三个类型"><a href="#4-决策树的三个类型" class="headerlink" title="4.决策树的三个类型"></a>4.决策树的三个类型</h4><h5 id="4-1-ID3"><a href="#4-1-ID3" class="headerlink" title="4.1 ID3"></a>4.1 ID3</h5><ol><li><p>原理：</p><p><code>1.</code>选取一个特征，计算<code>父亲节点</code>的信息熵；<br><code>2.</code>使用<code>此特征</code>的<code>所有取值</code>进行<code>预分枝</code>，并分别<code>计算信息增益</code>；<br><code>3.</code>从上面所有的信息增益中，选取信息增益<code>最大</code>的<code>特征值</code>，并进行分枝；<br><code>4.</code>将子节点作为<code>另一个特征</code>的父亲节点，<code>重复1~3</code>，进行下一层的分枝操作。</p></li><li><p>图例：</p><img src="https://img-blog.csdnimg.cn/2019071516014771.png" width="70%"><img src="https://img-blog.csdnimg.cn/20190715160235460.png" width="70%"><img src="https://img-blog.csdnimg.cn/20190715160255742.png" width="70%"><img src="https://img-blog.csdnimg.cn/20190715160317899.png" width="70%"></li></ol><ol start="3"><li>缺点</li></ol><ul><li>不过，信息增益有一个问题：对可取值数目较多的属性有所偏好，例如：考虑将“编号”作为一个属性。为了解决这个问题，引出了另一个 算法C4.5。<h5 id="4-2-C4-5"><a href="#4-2-C4-5" class="headerlink" title="4.2 C4.5"></a>4.2 C4.5</h5></li></ul><ol><li>信息增益率：</li></ol><ul><li>为了解决<code>信息增益偏向于取值多的特征</code>的问题，引入一个新的表示方法：信息增益率：<br>$$Gain_ratio(D,A)=\frac{Gain(D,a)}{IV(A)}$$<br>其中，$IV(A)$为<code>惩罚项</code>，$IV(A)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}$，意为*D关于特征A的值的熵$Ent_A(D)$*，不同于$Ent(D,A)$。<br>当：属性$A$的取值数目越多(即V越大)，则惩罚项IV(A)的值通常就越大，惩罚参数$\frac{1}{IV(A)}$越小，信息增益率$Gain_ratio$越小。这样就可以避免模型偏好特征值多的属性。</li></ul><ol start="2"><li>原理：</li></ol><ul><li>和ID3生成树的过程类似，只是选择的标准换成的信息增益率。</li></ul><ol start="3"><li>缺点：</li></ol><ul><li>信息增益率偏向取值较少的特征。如果简单的按照这个规则来分割，模型又会偏向特征数少的特征。因此C4.5决策树先从候选划分属性中找出<code>信息增益高于平均水平</code>的属性，在从中选择<code>增益率最高</code>的。</li></ul><h5 id="4-3-CART-Classification-and-Regression-Tree"><a href="#4-3-CART-Classification-and-Regression-Tree" class="headerlink" title="4.3 CART(Classification and Regression Tree)"></a>4.3 CART(Classification and Regression Tree)</h5><ul><li><p>简介：</p><ul><li>CART和普通的决策树类似，过程也是特征选择、树的生成及剪枝。但既可以用于分类也可以用于回归。</li></ul></li><li><p>回归树的生成：</p><ul><li>原理：<br>CART回归树是假设树为<code>二叉树</code>，通过不断将特征进行分裂。比如当前树结点是基于<code>第j个特征值</code>进行分裂的，设该特征值小于<code>阈值s</code>的样本划分为左子树，大于s的样本划分为右子树。<br>$$R_1(j,s)={x|x_j≤s} $$$$R_2(j,s)={x|x_j&gt;s}$$<br>典型CART回归树使用<code>平方误差</code>来表示回归树在Train上的预测误差，即：<br>$$\sum_{x^{(i)}∈R_m}(y^{(i)}-f(x^{(i)}))^2$$<br>因此，当我们为了求解<code>最优的切分特征</code>$x_j$和<code>最优的切分点s</code>，就转化为求解这么一个目标函数：<br>$$min_{j,s}[min_{c_1}\sum_{x^{(i)}∈R_1(j,s)}(y^{(i)}-c_1)^2+\sum_{x^{(i)}∈R_2(j,s)}min_{c_2}(y^{(i)}-c_2)^2]$$<br>所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。</li><li>实现过程：将D的每个特征空间分别划分成两个子区域并决定输出值，构建二叉决策树。<ul><li>input：训练集D</li><li>选择最优切分特征$x_j$和阈值s，即：<br>对此切分特征$x_j$，选取损失函数能取最小值的对$(j,s)$<br>$$min_{j,s}[min_{c_1}\sum_{x^{(i)}∈R_1(j,s)}(y^{(i)}-c_1)^2+\sum_{x^{(i)}∈R_2(j,s)}min_{c_2}(y^{(i)}-c_2)^2]$$</li><li>用选定的对$(j,s)$划分区域，输出对应值：</li><li>对于<code>划分出的两个区域</code>，重复上面两两步，直到满足结束条件；</li><li>output：决策树</li></ul></li></ul></li><li><p>分类树的生成：</p><ul><li>简介：<br>分类树用<code>基尼指数</code>（和熵的含义类似）选择最优特征，同时决定该特征的切分点。<ul><li>基尼指数：</li></ul></li></ul><ul><li><p>基尼指数表示在样本集合中一个随机选中的样本被分错的概率。**$Gini(D,A)$越小，数据集D的纯度越高**。<br>$$Gini(D)=\sum_{k=1}^{|y|}\sum_{k’≠k}p_kp_k’=1-\sum_{k=1}^{|y|}p_k^2$$<br>其中，$|y|$仍表示<code>标签列</code>可取值的个数。等式后半部分也容易证明，此处不再赘述。</p></li><li><p>实现过程：</p><ul><li>input：训练集D，结束条件；</li><li>遍历所有特征，对每个特征的所有取值，根据$A==a$<code>为T/F</code>将D分割为$D_1$和$D_2$，并计算基尼指数；</li><li>在所有特征的所有取值中，选取Gini最小的特征及其切分点，从现结点生成两个子节点；</li><li>重复上面两步；</li><li>output：CART决策树</li></ul></li><li><p>举个栗子：</p></li><li><p>假设现在有特征 “学历”，此特征有三个特征取值： “本科”，“硕士”， “博士”，<br>当使用“学历”这个特征对样本集合D进行划分时，划分值分别有三个，因而有三种划分的可能集合，划分后的子集如下：</p><ul><li>1.划分点： “本科”，划分后的子集合 ： {本科}，{硕士，博士}</li><li>2.划分点： “硕士”，划分后的子集合 ： {硕士}，{本科，博士}</li><li>3.划分点： “博士”，划分后的子集合 ： {博士}，{本科，硕士}}</li></ul></li><li><p>对于上述的每一种划分，都可以求出对应的基尼指数$Gini(D,A^{(i)})$：<br>$$Gini(D,A^{(i)})=\frac{D_1}{D}Gini(D_2)+\frac{D_2}{D}Gini(D_2)$$<br>上式中，$A^{(i)}$表示学历的第i个特征值，如“本科”、“硕士”或“博士”。。<br>然后从所有的可能划分的$Gini(D,A^{(i)})$中找出$Gini$指数<code>最小</code>的划分，这个划分的划分点，便是使用特征A对样本集合D进行划分的最佳划分点。</p></li></ul></li></ul><h5 id="4-4-三种类型总结"><a href="#4-4-三种类型总结" class="headerlink" title="4.4 三种类型总结."></a><font color='red'>4.4 三种类型总结</font>.</h5><ul><li>ID3：</li><li>取值多的属性，更容易使数据更纯，其信息增益更大。</li><li>训练得到的是一棵庞大且深度浅的树：不合理。</li><li>C4.5：采用信息增益率替代信息增益。</li><li>CART：</li><li>以基尼系数替代熵，最小化不纯度，而不是最大化信息增益。</li><li>相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。</li></ul><h4 id="5-剪枝"><a href="#5-剪枝" class="headerlink" title="5.剪枝"></a>5.剪枝</h4><h5 id="5-1-ID3剪枝"><a href="#5-1-ID3剪枝" class="headerlink" title="5.1 ID3剪枝"></a>5.1 ID3剪枝</h5><ul><li>简介：ID3剪枝是一种简单的决策树学习的剪枝算法。</li><li>原理：<br>决策树的剪枝通常是<code>最小化决策树整体的损失函数</code>：<br>$$<br>\begin{aligned}<br>C_\alpha(T)&amp;=C(T)+\alpha|T|\<br>&amp;=\sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T|\<br>&amp;=\sum_{t=1}^{|T|}N_t(-\sum_{k=1}^{K}\frac{N_{tk}}{N_t}log\frac{N_{tk}}{N_t})+\alpha|T|\<br>&amp;=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}log\frac{N_{tk}}{N_t}+\alpha|T|<br>\end{aligned}<br>$$<br>其中$H_t(T)$表示<code>叶节点t</code>上的熵，相当于前面的$Ent(D^v)$，|T|为<code>树T</code>的<code>叶节点个数</code>，第t个叶节点有$N_t$个样本点，其中属于k类的样本点有$N_{tk}$个。<code>α|T|</code>为惩罚项，用于控制模型复杂度。</li><li>实现过程：<ul><li>input：生成的树T，参数α</li><li>计算每个节点的熵；</li><li>递归地从树的叶节点向上回缩，<br>设这一组叶节点回缩<code>前后</code>整体树分别为$T$和$T’$，若$C_\alpha(T’)≤C_\alpha(T)$，则剪枝，即父节点变为新的叶节点；</li><li>返回前一步，知道满足结束条件；</li><li>output：修剪后的树$T_\alpha$</li></ul></li><li>可以看出，决策树的生成只考虑了通过提高Gain或Gain_ratio对训练数据进行更好的拟合，而决策树剪枝通过极小化损失函数降低了模型的复杂度。即<code>决策树生成</code>学习局部的模型，而<code>决策树剪枝</code>学习整体的模型。<h5 id="5-2-CART剪枝"><a href="#5-2-CART剪枝" class="headerlink" title="5.2 CART剪枝"></a>5.2 CART剪枝</h5><h4 id="6-应用的建议"><a href="#6-应用的建议" class="headerlink" title="6.应用的建议."></a><font color='red'>6.应用的建议</font>.</h4></li><li>优缺点<ul><li>优点：<ul><li>可解释性强，有助于人工分析；</li><li><code>blablabla</code></li></ul></li><li>缺点：<ul><li>决策树结果不稳定，数据中很小的改变可能对生成的树产生很大的影响；</li><li>需要平衡数据； </li></ul></li></ul></li><li>树形结构为何不需要归一化？<ul><li>因为树模型是将特征值排列之后选取阈值来进行分枝的，<code>只关注特征值的分布</code>，而非具体数值。所以数值缩放<code>不影响分裂点</code>的位置。</li><li>另外，Tree不能进行GD：因为树模型是通过寻找分裂点来最优化的，即<code>间断式</code>。间断点是<code>不可导</code>的，且求导<code>无意思</code>，所以不需要归一化。</li><li>算法案例：DT、RF</li><li>需要归一化的算法：<br>许多非树形结构，如<code>Adaboost、SVM、LR、KNN、K-means...</code>归一化之后，在GB时可以减少迭代次数来加快速度。</li></ul></li><li>DT如何剪枝？<ul><li>预剪枝：其中的核心思想就是，在每一次实际对结点进行进一步划分之前，先采用验证集的数据来验证如果划分是否能提高划分的准确性。如果不能，就把结点标记为叶结点并退出进一步划分；如果可以就继续递归生成节点。</li><li>后剪枝：后剪枝则是先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来泛化性能提升，则将该子树替换为叶结点。<h4 id="7-sklearn-tree代码："><a href="#7-sklearn-tree代码：" class="headerlink" title="7.sklearn.tree代码："></a>7.sklearn.tree代码：</h4></li></ul></li></ul><p><em><a href="https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/3.Desition%20Tree/DecisionTree.ipynb" >用决策树分类并可视化</a></em></p>]]></content>
    
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzy-Cmeans</title>
    <link href="/2019/11/15/Fuzzy-Cmeans/"/>
    <url>/2019/11/15/Fuzzy-Cmeans/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><ul><li><a href="https://en.wikipedia.org/wiki/Fuzzy_clustering">Fuzzy clustering - Wikipedia</a></li></ul><h4 id="一、原理简述"><a href="#一、原理简述" class="headerlink" title="一、原理简述"></a>一、原理简述</h4><p>​    Fuzzy-Cmeans（Fuzzy clustering means，模糊均值聚类）</p><p>​    设原数据$X，shape=(m*n)$，要分为$k$个类：</p><ol><li>初始化隶属矩阵，第$i$个样本$x^{(i)}$的隶属矩阵如下（需要归一化，确保概率和为1。$M_{origin}^{(i)}$、$M^{(i)}$分别为归一化前后的隶属矩阵矩阵，$M.shape=(m*k)$）</li></ol><p>$$<br>M_{origin}^{(i)}=[random()\ for\ j\ in\ range(k)]\<br>M^{(i)}=M_{origin}^{(i)}/sum(M_{origin}^{(i)})<br>$$</p><a id="more"></a><ol start="2"><li><p>计算类中心：</p><p>其中，$w_j^{(i)}$表示第$i$个样本属于第$j$个类的概率</p></li></ol><p>$$<br>c_j=\frac{\sum_i^m\omega_j^{(i)}x^{(i)}}{\sum_i^m\omega_j^{(i)}},j=1,2…k<br>$$</p><ol start="3"><li><p>更新隶属矩阵(相当于K-means中归类的步骤)：</p><p>其中，$c_j$为第$j$个类中心的坐标<br>$$<br>w_j^{(i)}=\frac{1}{\sum_{t=1}^{k}(\frac{||x^{(i)}-c_j||}{||x^{(i)}-c_t||})^2}<br>$$</p></li><li><p>损失函数：<br>$$<br>J=\sum_i^m\sum_j^kw_{ij}||x^{(i)}-c_j||^2<br>$$</p></li></ol><h4 id="二、Python代码"><a href="#二、Python代码" class="headerlink" title="二、Python代码"></a>二、Python代码</h4><h5 id="2-1-迭代计算-详细代码可以查看：Fuzzy-Cmeans"><a href="#2-1-迭代计算-详细代码可以查看：Fuzzy-Cmeans" class="headerlink" title="2.1 迭代计算(详细代码可以查看：Fuzzy-Cmeans)"></a>2.1 迭代计算(详细代码可以查看：<a href="https://github.com/C-Yunfeng/ML-algorithms/blob/master/Fuzzy-Cmeans.ipynb">Fuzzy-Cmeans</a>)</h5><ul><li>初始化隶属矩阵：</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_proba_mat</span>(<span class="hljs-params">X,k</span>):</span>    proba_mat = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">0</span>]):        random_list = [random.random() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k)]        proba_lst = [x/sum(random_list) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> random_list]        proba_mat.append(proba_lst)    <span class="hljs-keyword">return</span> proba_mat</code></pre><ul><li>计算簇中心：</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_center_lst</span>(<span class="hljs-params">X,proba_mat,k,m</span>):</span>    <span class="hljs-comment">#计算聚类中心</span>    proba_mat_T = np.array(proba_mat).T    center_lst = []    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):        center_proba_lst = proba_mat_T[j]  <span class="hljs-comment">#1*10</span>        proba_power_lst=[center_proba ** m <span class="hljs-keyword">for</span> center_proba <span class="hljs-keyword">in</span> center_proba_lst]        denominator = sum(proba_power_lst) <span class="hljs-comment">#分母</span>                product_lst = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">0</span>]):            point = X.iloc[i]            product = [proba_power_lst[i] * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> point]  <span class="hljs-comment">#element like [proba*x,proba*y]</span>            product_lst.append(product)                numerator = np.sum(product_lst,axis=<span class="hljs-number">0</span>)  <span class="hljs-comment">#分子</span>        center = [x/denominator <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> numerator]        center_lst.append(center)    lst_course.append(center_lst)    <span class="hljs-keyword">return</span> center_lst</code></pre><ul><li>更新隶属矩阵</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_proba_mat</span>(<span class="hljs-params">X,center_lst,proba_mat,k,m</span>):</span>    <span class="hljs-comment">#更新隶属矩阵</span>    p = <span class="hljs-number">2</span>/(m<span class="hljs-number">-1</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">0</span>]):        x = X.iloc[i]        distances = [np.linalg.norm(x-center_lst[j]) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k)]        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):            den = sum([(distances[j]/distances[c])**p <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(k)])            proba_mat[i][j] = <span class="hljs-number">1</span>/den    <span class="hljs-keyword">return</span> proba_mat</code></pre><ul><li>迭代</li></ul><pre><code class="hljs python"><span class="hljs-comment">#迭代</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fuzzyCMeansClustering</span>(<span class="hljs-params">X,proba_mat,center_lst,k,m,max_iter</span>):</span>    curr = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> curr &lt;= max_iter:        center_lst = get_center_lst(X,proba_mat,k,m)        proba_mat = update_proba_mat(X,center_lst,proba_mat,k,m)        curr += <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> proba_mat,center_lst</code></pre><ul><li>主函数：</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pddf = pd.DataFrame(&#123;    <span class="hljs-string">&#x27;x&#x27;</span>: [<span class="hljs-number">12</span>, <span class="hljs-number">20</span>, <span class="hljs-number">28</span>, <span class="hljs-number">18</span>, <span class="hljs-number">29</span>, <span class="hljs-number">33</span>, <span class="hljs-number">24</span>, <span class="hljs-number">45</span>, <span class="hljs-number">45</span>, <span class="hljs-number">52</span>, <span class="hljs-number">51</span>, <span class="hljs-number">52</span>, <span class="hljs-number">55</span>, <span class="hljs-number">53</span>, <span class="hljs-number">55</span>, <span class="hljs-number">61</span>, <span class="hljs-number">64</span>, <span class="hljs-number">69</span>, <span class="hljs-number">72</span>],    <span class="hljs-string">&#x27;y&#x27;</span>: [<span class="hljs-number">39</span>, <span class="hljs-number">36</span>, <span class="hljs-number">30</span>, <span class="hljs-number">52</span>, <span class="hljs-number">54</span>, <span class="hljs-number">46</span>, <span class="hljs-number">55</span>, <span class="hljs-number">59</span>, <span class="hljs-number">63</span>, <span class="hljs-number">70</span>, <span class="hljs-number">66</span>, <span class="hljs-number">63</span>, <span class="hljs-number">58</span>, <span class="hljs-number">23</span>, <span class="hljs-number">14</span>, <span class="hljs-number">8</span>, <span class="hljs-number">19</span>, <span class="hljs-number">7</span>, <span class="hljs-number">24</span>]&#125;)X=dfk=<span class="hljs-number">3</span>m=<span class="hljs-number">2</span>max_iter=<span class="hljs-number">15</span>lst_course=[]begin_mat=get_proba_mat(X,k)begin_centers=get_center_lst(X,begin_mat,k,m)end_mat,end_centers=fuzzyCMeansClustering(X,begin_mat,begin_centers,k,m,max_iter)</code></pre><h5 id="2-2-可视化迭代过程："><a href="#2-2-可视化迭代过程：" class="headerlink" title="2.2 可视化迭代过程："></a>2.2 可视化迭代过程：</h5><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_course</span>(<span class="hljs-params">X,lst_course</span>):</span>    plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>))    plt.scatter(X.iloc[:,<span class="hljs-number">0</span>], X.iloc[:,<span class="hljs-number">1</span>],c=X[<span class="hljs-string">&#x27;label&#x27;</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst_course)<span class="hljs-number">-1</span>):        plt.scatter(np.array(lst_course[i]).T[<span class="hljs-number">0</span>], np.array(lst_course[i]).T[<span class="hljs-number">1</span>],marker=<span class="hljs-string">&quot;s&quot;</span>,s=<span class="hljs-number">20</span>,color=<span class="hljs-string">&#x27;r&#x27;</span>)        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k):            x1=lst_course[i][j][<span class="hljs-number">0</span>]            y1=lst_course[i][j][<span class="hljs-number">1</span>]            x2=lst_course[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]            y2=lst_course[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]            dx = (x2 - x1)            dy = (y2 - y1)            <span class="hljs-keyword">if</span> i!=len(lst_course)<span class="hljs-number">-2</span>:                plt.arrow(x1, y1, dx, dy,color=<span class="hljs-string">&#x27;red&#x27;</span>)            <span class="hljs-keyword">else</span>:                plt.arrow(x1, y1, dx, dy,head_width=<span class="hljs-number">1</span>,head_length=<span class="hljs-number">1.5</span>,color=<span class="hljs-string">&#x27;r&#x27;</span>)        fname=<span class="hljs-string">&#x27;&#123;&#125;/imgs/&#123;&#125;.png&#x27;</span>.format(cwd,i)        plt.savefig(fname, dpi=<span class="hljs-literal">None</span>, facecolor=<span class="hljs-string">&#x27;w&#x27;</span>, edgecolor=<span class="hljs-string">&#x27;w&#x27;</span>)    plt.show()</code></pre><ul><li>可视化主函数：</li></ul><pre><code class="hljs python">plot_course(X_end,lst_course)</code></pre><p><img src="https://user-images.githubusercontent.com/49241298/72425740-50aeba00-37c3-11ea-8377-22b3319c5cb3.png"></p><ul><li>导出为gif：(装moviepy遇到已存在不能安装的问题时，可以用pip install –ignore –installed moviepy –user)</li></ul><pre><code class="hljs python"><span class="hljs-keyword">from</span> moviepy.editor <span class="hljs-keyword">import</span> ImageSequenceClippath=<span class="hljs-string">&#x27;&#123;&#125;/imgs&#x27;</span>.format(cwd)img_names = [<span class="hljs-string">&#x27;&#123;&#125;/&#123;&#125;.png&#x27;</span>.format(path,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">16</span>)]clip = ImageSequenceClip(img_names,fps=<span class="hljs-number">3</span>)clip.write_gif(<span class="hljs-string">&#x27;&#123;&#125;/demo.gif&#x27;</span>.format(path))</code></pre><p><img src="https://user-images.githubusercontent.com/49241298/72425744-53111400-37c3-11ea-9637-516f178cdea3.gif"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>K-means</title>
    <link href="/2019/11/15/K-means/"/>
    <url>/2019/11/15/K-means/</url>
    
    <content type="html"><![CDATA[<h4 id="一、原理简述"><a href="#一、原理简述" class="headerlink" title="一、原理简述"></a>一、原理简述</h4><ol><li>损失函数：</li></ol><p>$$<br>J(c^{(i)}…c^{(m)},μ_1…μ<em>k)=\frac{1}{m}||x^{(i)}-μ</em>{c^{(i)}}||^2<br>$$</p><p>​        设选定$k$个簇，则$c^{(i)}$表示$x^{(i)}$的标签，$即(c^{(i)}=1,2….k)$；$μ<em>k$表示第$k$个簇中心的坐标；$μ</em>{c^{(i)}}$表示$x^{(i)}$所属簇的簇中心。</p><a id="more"></a><ol start="2"><li><p>簇中心初始化：</p><p>从数据集中随机选取$k$个样本作为簇中心，即：$μ_1,…,μ_k=x^{(i)},…,x^{(j)}$</p></li><li><p>样本归类：</p></li></ol><p>$$<br>c^{(i)}=index(min(||x^{(i)}-μ<em>j||^2))，for_j_in\</em>[1,2…k]<br>$$</p><ol start="4"><li>更新中心：设$S_j$为总样本集中属于第$j$个簇的样本集合。</li></ol><p>$$<br>c_j=avg(S_j)<br>$$</p><p>​        即将$S_j$所有样本点坐标的均值作为中心的新坐标。</p><ol start="5"><li>不断迭代，如下图：</li></ol><p><img src="https://user-images.githubusercontent.com/49241298/72425946-bdc24f80-37c3-11ea-8fe5-56a822ed1be0.png"></p><h4 id="二、Python代码"><a href="#二、Python代码" class="headerlink" title="二、Python代码"></a>二、Python代码</h4><ul><li>伪代码：(详细代码可以查看：<a href="https://github.com/C-Yunfeng/ML-algorithms/blob/master/K-means.ipynb">K-means.ipynb</a>)</li></ul><pre><code class="hljs python"><span class="hljs-comment">#初始化中心</span>centroids = &#123;    i+<span class="hljs-number">1</span>: [np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">80</span>), np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">80</span>)]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k)&#125;<span class="hljs-comment">#将样本归类</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assignment</span>(<span class="hljs-params">df, centroids</span>):</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> centroids.keys():        <span class="hljs-comment"># sqrt((x1 - x2)^2 - (y1 - y2)^2)</span>        df[<span class="hljs-string">&#x27;distance_from_&#123;&#125;&#x27;</span>.format(i)] = (            np.sqrt(                (df[<span class="hljs-string">&#x27;x&#x27;</span>] - centroids[i][<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span>                + (df[<span class="hljs-string">&#x27;y&#x27;</span>] - centroids[i][<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>            )        )    centroid_distance_cols = [<span class="hljs-string">&#x27;distance_from_&#123;&#125;&#x27;</span>.format(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> centroids.keys()]    df[<span class="hljs-string">&#x27;closest&#x27;</span>] = df.loc[:, centroid_distance_cols].idxmin(axis=<span class="hljs-number">1</span>)    df[<span class="hljs-string">&#x27;closest&#x27;</span>] = df[<span class="hljs-string">&#x27;closest&#x27;</span>].map(<span class="hljs-keyword">lambda</span> x: int(x.lstrip(<span class="hljs-string">&#x27;distance_from_&#x27;</span>)))    df[<span class="hljs-string">&#x27;color&#x27;</span>] = df[<span class="hljs-string">&#x27;closest&#x27;</span>].map(<span class="hljs-keyword">lambda</span> x: colmap[x])    <span class="hljs-keyword">return</span> df<span class="hljs-comment">#更新中心</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">k</span>):</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> centroids.keys():        centroids[i][<span class="hljs-number">0</span>] = np.mean(df[df[<span class="hljs-string">&#x27;closest&#x27;</span>] == i][<span class="hljs-string">&#x27;x&#x27;</span>])        centroids[i][<span class="hljs-number">1</span>] = np.mean(df[df[<span class="hljs-string">&#x27;closest&#x27;</span>] == i][<span class="hljs-string">&#x27;y&#x27;</span>])    <span class="hljs-keyword">return</span> k</code></pre><ul><li><p>过程图示：</p><ul><li><p>初始化中心</p><p><img src="https://user-images.githubusercontent.com/49241298/72425947-bef37c80-37c3-11ea-8ccc-e07904245f72.png"></p></li><li><p>样本归类</p><p><img src="https://user-images.githubusercontent.com/49241298/72425951-c0bd4000-37c3-11ea-85cc-b11980d00322.png"></p></li><li><p>更新中心</p><p><img src="https://user-images.githubusercontent.com/49241298/72425955-c155d680-37c3-11ea-9294-9f40abc2a63b.png"></p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
